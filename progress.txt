# Ralph Progress Log
# Repository: modplug/loops

# ============================================================
# PRD #71: Transport, Master Track, Mixer, MIDI Parameter Control
# Issues: #72-#81 (10 vertical slices)
# ============================================================

## Issue Dependency Graph
# #72 Keyboard shortcuts — no blockers
# #73 Click-to-position — no blockers
# #74 Time signature selector — no blockers
# #75 Master track — no blockers
# #76 Metronome enhancements — blocked by #75
# #77 Mixer view — blocked by #75
# #78 Track volume & pan automation — no blockers
# #79 Track inspector — no blockers
# #80 MIDI Learn for parameters — no blockers
# #81 Expression pedal quick-assign — blocked by #80

## Completed
### Iteration 1 — #72 Keyboard shortcuts: transport, navigation & editing
- `ProjectViewModel`: `selectedTrackID: ID<Track>?` for keyboard-driven track focus
- `ProjectViewModel`: `selectedContainerIDs: Set<ID<Container>>` for multi-select (Cmd+A)
- `selectAllContainers()` populates set with all container IDs in current song
- `deselectAll()` clears all selection state (container, track, section, multi-select)
- `selectTrackByIndex(_:)` sets selectedTrackID by 0-based index
- `lastBarWithContent` computed property: max endBar across containers and sections
- Transport shortcuts: Space (play/pause, already existed — verified), R (toggle record arm on selected track), M (toggle metronome)
- Navigation shortcuts: Left/Right arrows (nudge playhead ±1 bar), Home/Fn+Left (jump to bar 1), End/Fn+Right (jump to last bar with content), 1-9 (select track by index)
- Editing shortcuts: Cmd+D (duplicate selected container, or track if none), Cmd+A (select all containers), Escape (deselect all + clear range/track selection), Tab (cycle inspector mode)
- Existing shortcuts verified: Space (play/pause), Return (open detail editor), Delete (delete selected container/breakpoint), Cmd+C/V (copy/paste)
- Shortcuts fire via `.onKeyPress` on MainContentView; do not conflict with TextField focus
- 8 new tests: selectAllContainers, selectAllContainers empty, deselectAll, selectTrackByIndex, selectTrackByIndex out-of-range, lastBarWithContent, lastBarWithContent max of both, duplicate container undo/redo
- All 394 tests pass

### Iteration 2 — #73 Click-to-position: playhead positioning on ruler & timeline
- `TimelineViewModel`: `snappedBar(forXPosition:timeSignature:)` — snaps to bar at low zoom, to beat at high zoom (threshold: 40px per beat)
- `TransportViewModel`: `seek(toBar:)` — seeks playhead; if playing, stops/restarts PlaybackScheduler from new position
- `RulerView`: single click positions playhead (snapped), drag scrubs continuously, Shift+drag retains range selection behavior
- `RulerView`: `onPlayheadPosition` callback for playhead positioning
- `TimelineView`: click on empty grid area (no container hit) positions playhead via `onPlayheadPosition` callback
- `TimelineView`: `onTapGesture` on grid overlay with snapped bar conversion, does not interfere with container gestures
- `MainContentView`: wired both ruler and timeline `onPlayheadPosition` callbacks to `transportViewModel.seek(toBar:)`
- Pixel-to-bar snap logic: at low zoom (pixelsPerBeat < 40), rounds to nearest whole bar; at high zoom (pixelsPerBeat >= 40), rounds to nearest beat
- Seek during playback: pauses transport, stops scheduler, sets new position, re-prepares and replays from new bar
- Seek while stopped: directly sets playhead position
- 10 new tests: snappedBar at x=0, snappedBar at x=pixelsPerBar, snap-to-bar low zoom, snap-to-beat high zoom, various zoom levels, negative x clamping, 3/4 time signature, setPlayhead during playback, setPlayhead while stopped, setPlayhead fires callback
- All 404 tests pass

### Iteration 3 — #74 Time signature selector: UI control with grid/ruler/metronome update
- `ProjectViewModel`: `setTimeSignature(songID:beatsPerBar:beatUnit:)` with full undo/redo
- Validation: beatsPerBar 1–12, beatUnit in {2, 4, 8, 16}; rejects invalid values, no-op on same value
- `ToolbarView`: replaced display-only text with `Menu` picker showing 6 presets (2/4, 3/4, 4/4, 5/4, 6/8, 7/8)
- `ToolbarView`: `onTimeSignatureChange` callback for decoupled communication
- `LoopsRootView`: wires toolbar callback to `ProjectViewModel.setTimeSignature`
- `LoopsRootView`: bidirectional sync — Song → TransportViewModel on song change, initial sync on appear
- Grid overlay (`GridOverlayView`) already reactive: uses `timeSignature.beatsPerBar` for beat subdivisions
- Ruler (`RulerView`) already reactive: uses `timeSignature.beatsPerBar` for beat ticks and snap logic
- Metronome already reactive: `MetronomeGenerator.update(bpm:beatsPerBar:sampleRate:)` called on play/seek with current time signature
- Changing time signature does NOT reposition existing containers (bars stay at same bar numbers)
- 8 new tests: setTimeSignature basic, undo/redo, invalid beatsPerBar (0/13/-1), invalid beatUnit (3/5/0), all valid beatUnits (2/4/8/16), beatsPerBar boundary values (1/12), no-op same value, containers not repositioned
- All 412 tests pass

# ============================================================
# PRD #60: Workflow & Live Performance (COMPLETE)
# Issues: #61-#70 (10 vertical slices) — all closed
# ============================================================

## Issue Dependency Graph
# #61 Track record arming — no blockers
# #62 Count-in — no blockers
# #63 Per-track MIDI routing — no blockers
# #64 Input monitoring — blocked by #61
# #65 Section regions — no blockers
# #66 Container clones — no blockers
# #67 Automation timeline visualization — no blockers
# #68 Context menus — blocked by #65, #66
# #69 Time range selection & section copy — blocked by #65
# #70 Storyline inspector — blocked by #65

## Completed
### Iteration 1 — #61 Track record arming: model, UI indicator & serialization
- Added `isRecordArmed: Bool` (default `false`) to Track model
- Backward-compatible decoding (defaults to `false` for old project files)
- `setTrackRecordArmed(trackID:armed:)` on ProjectViewModel with full undo/redo
- TrackHeaderView: record arm button (red circle icon, filled when armed, outline when unarmed) next to M/S buttons
- Armed tracks show red tint on header background
- MainContentView: wired onRecordArmToggle callback to ProjectViewModel
- duplicateSong copies isRecordArmed to duplicated tracks
- 4 new tests: Track Codable round-trip with isRecordArmed, backward-compat decode without isRecordArmed, setTrackRecordArmed toggle, undo/redo setTrackRecordArmed
- All 271 tests pass

### Iteration 2 — #62 Count-in: configurable metronome bars before recording
- Added `countInBars: Int` (default `0`) to Song model
- Backward-compatible decoding (defaults to `0` for old project files)
- New `TransportState.countingIn` state: when record-armed with countInBars > 0, transport enters count-in phase
- TransportManager: metronome plays during count-in, transitions to `.recording` after N bars elapse
- `countInDuration(bars:)` method for timing calculations (bars × barDuration at current BPM/time signature)
- Callbacks: `onCountInComplete` (triggers audio scheduling), `onCountInTick` (updates remaining count)
- TransportViewModel: wires count-in state, enables metronome during count-in, defers audio scheduling until count-in completes
- ToolbarView: count-in picker (0, 1, 2, 4 bars) next to metronome toggle, visual countdown display ("Count: N...") during count-in
- `setCountInBars(songID:bars:)` on ProjectViewModel with full undo/redo
- LoopsRootView: syncs countInBars between Song model and TransportViewModel bidirectionally
- duplicateSong copies countInBars to duplicated songs
- 11 new tests: Song Codable round-trip with countInBars, legacy decode without countInBars, count-in timing calculation, count-in=0 starts immediately, count-in enters countingIn state, count-in without record arm plays normally, stop/pause during count-in, setCountInBars update, undo/redo, duplicateSong copies countInBars
- All 282 tests pass

### Iteration 3 — #63 Per-track MIDI input device & channel routing
- Added `midiInputDeviceID: String?` (nil = no filter / system default) to Track model
- Added `midiInputChannel: UInt8?` (nil = omni, 1-16 = specific channel) to Track model
- Backward-compatible decoding (defaults to nil for both fields)
- New `MIDIInputDevice` model: id + displayName for MIDI source identification
- New `MIDITrackFilter` with static `matches(eventDeviceID:eventChannel:trackDeviceID:trackChannel:)` for per-track filtering
- MIDIManager: tracks source device IDs via CoreMIDI kMIDIPropertyUniqueID + srcConnRefCon
- MIDIManager: new `onMIDIEventFromDevice` callback includes source device ID
- MIDIManager: new `availableInputDevices()` returns `[MIDIInputDevice]`
- AudioEngineManager: added `midiManager` property for centralized MIDI access
- `setTrackMIDIInput(trackID:deviceID:channel:)` on ProjectViewModel with full undo/redo
- TrackHeaderView: MIDI device name + channel labels for MIDI tracks (pianokeys + number icons)
- MainContentView: MIDI Device and MIDI Channel context menus on MIDI track headers
- duplicateSong copies midiInputDeviceID and midiInputChannel to duplicated tracks
- 13 new tests: Track Codable round-trip with MIDI fields, backward-compat decode without MIDI fields, omni channel round-trip, MIDITrackFilter matching/blocking (8 cases), setTrackMIDIInput, undo/redo setTrackMIDIInput
- All 295 tests pass

### Iteration 4 — #64 Input monitoring: hear input through track effects
- Added `isMonitoring: Bool` (default `false`) to Track model
- Backward-compatible decoding (defaults to `false` for old project files)
- New `InputMonitor` engine class: manages per-track input monitoring audio subgraphs
- InputMonitor routes engine.inputNode → shared distributor → [per-track AU effects] → monitoring mixer → mainMixer
- `suppressMonitoring(trackID:)` / `unsuppressMonitoring(trackID:)` for auto-disable during container playback
- PlaybackScheduler: tracks container→track mapping, auto-suppresses monitoring when containers play on a track, auto-unsuppresses on stop
- AudioEngineManager: creates/destroys InputMonitor with engine lifecycle
- TransportViewModel: `setInputMonitoring(track:enabled:)` starts engine if needed, enables/disables monitoring
- `setTrackMonitoring(trackID:monitoring:)` on ProjectViewModel with full undo/redo
- TrackHeaderView: headphone icon button (orange when active), orange tint on track header background when monitoring
- MainContentView: wired onMonitorToggle callback to ProjectViewModel and TransportViewModel
- duplicateSong copies isMonitoring to duplicated tracks
- 9 new tests: Track Codable round-trip with isMonitoring, backward-compat decode without isMonitoring, setTrackMonitoring toggle, undo/redo setTrackMonitoring, monitoring auto-disables during playback, monitoring re-enables after playback stops, suppress non-monitored track no-op, disable monitoring removes track, cleanup removes all
- All 304 tests pass

### Iteration 5 — #65 Section regions: named colored markers on timeline
- New `SectionRegion` model: `id: ID<SectionRegion>`, `name: String`, `startBar: Int`, `lengthBars: Int`, `color: String` (hex), `notes: String?`, computed `endBar`
- `Song` gains `sections: [SectionRegion]` (default `[]`)
- Backward-compatible decoding (defaults to `[]` for old project files)
- `ProjectViewModel`: addSection, removeSection, moveSection, resizeSection, renameSection, recolorSection, setSectionNotes — all with full undo/redo
- Overlap validation on add/move/resize (reject if overlapping existing section)
- `selectedSectionID: ID<SectionRegion>?` selection tracking on ProjectViewModel
- `SectionLaneView`: colored bands rendered on a dedicated section lane between ruler and track area
- Drag on empty section lane to create new sections (default name "Section N")
- Move sections by dragging center, resize by dragging left/right edges
- Click section to select and navigate playhead to section start
- Double-click section to rename via popover
- Section name label displayed on each band
- `duplicateSong` copies sections with new IDs
- `MainContentView`: "Sections" label in header column, wired all section callbacks
- 16 new tests: SectionRegion Codable round-trip, Song with sections round-trip, legacy decode without sections, add section, default name auto-increment, overlap prevention, remove section, move section, move overlap prevention, resize section, resize overlap prevention, rename section, recolor section, undo/redo add, undo/redo remove, duplicateSong copies sections
- All 320 tests pass

### Iteration 6 — #66 Container linked clones: copy-on-write with override tracking
- New `ContainerField` enum: `effects`, `automation`, `fades`, `enterActions`, `exitActions`, `name`, `loopSettings`, `instrumentOverride`
- Added `parentContainerID: ID<Container>?` and `overriddenFields: Set<ContainerField>` to Container model
- Backward-compatible decoding (defaults to nil / [] for old project files)
- Computed `isClone` property, `resolved(parent:)` field-by-field resolution (non-overridden fields inherit from parent)
- `resolved(using:)` convenience with lookup closure for engine use
- Clone position fields (startBar, lengthBars) always local — only content fields inherit
- No nested clones: cloning a clone links to the original parent
- `ProjectViewModel`: `cloneContainer` (overlap-checked), `consolidateContainer` (resolves then disconnects), both with full undo/redo
- Auto-override: all container editing methods (name, effects, instrument, fades, actions, automation, loopSettings) mark the relevant `ContainerField` as overridden on clones
- `findContainer(id:)` helper for cross-track parent lookup
- `duplicateSong` copies parentContainerID and overriddenFields
- PlaybackScheduler: resolves clone fields in prepare(), play(), automation timer, and triggerStart
- OfflineRenderer: resolves clone fields before rendering
- ContainerView: link icon for clones, orange override-count badge, alt-drag clone gesture with dashed ghost preview
- TrackLaneView + TimelineView: wired `onCloneContainer` callback
- 14 new tests: ContainerField round-trip, clone fields round-trip, legacy decode, clone inheritance, clone override, no nesting, clone creation, overlap prevention, consolidate, clone undo/redo, consolidate undo/redo, auto-override marking, duplicateSong copies clone fields
- All 334 tests pass

### Iteration 7 — #67 Automation timeline visualization: overlay curves & sub-lanes
- New `AutomationOverlayView`: draws automation curves as semi-transparent colored lines on container bodies, breakpoint dots, parameter name labels
- New `AutomationSubLaneView`: dedicated sub-lane rows for each unique automation parameter with full breakpoint editing
- `AutomationCoordinateMapping` helper: pure functions for position↔x and value↔y coordinate conversion with clamping
- `AutomationColors` palette: 8 distinct colors for automation lane differentiation
- `TimelineViewModel`: `automationExpanded: Set<ID<Track>>` for per-track sub-lane toggle, `toggleAutomationExpanded(trackID:)`, `trackHeight(for:baseHeight:)` for variable per-track heights, `automationLaneCount(for:)` for unique path counting
- `ContainerView`: automation overlay rendered on container body when automation lanes exist
- `TrackLaneView`: sub-lane rendering below main lane when expanded, passes breakpoint callbacks (add/update/delete/select)
- `TrackHeaderView`: automation toggle button (waveform.path.ecg icon, purple when active), "Auto" indicator when track has automation, sub-lane parameter name labels with colored dots when expanded
- `TimelineView`: variable per-track heights based on automation expansion, `selectedBreakpointID` state, delete key removes selected breakpoint, `uniqueAutomationPaths(for:)` helper
- `MainContentView`: wires automation toggle, per-track heights, lane labels via `automationLaneLabels(for:)` and `automationPathLabel(_:)` helpers
- Sub-lane interaction: click to add breakpoint at position/value, drag breakpoints to move, select breakpoints, value tooltip on hover/drag
- 13 new tests: position-to-x mapping, value-to-y mapping, x-to-position mapping, y-to-value mapping, position round-trip, value round-trip, add breakpoint at click position, drag breakpoint updates, drag clamps to bounds, toggle automation expanded, track height with sub-lanes, track height no automation, lane count multiple containers
- All 347 tests pass

### Iteration 9 — #69 Time range selection & section copy/paste
- `TimelineViewModel`: `selectedRange: ClosedRange<Int>?` (transient bar range), `selectedTrackIDs: Set<ID<Track>>` for copy filter, `toggleTrackSelection(trackID:)`, `clearSelectedRange()`
- `ProjectViewModel`: `clipboardSectionRegion: SectionRegion?` stores section metadata for section copy
- Enhanced `copyContainersInRange(startBar:endBar:trackFilter:)` with optional track filter (empty = all tracks)
- `copySectionWithMetadata(sectionID:)`: copies containers in section range + section metadata
- `pasteContainersToOriginalTracks(atBar:)`: multi-track paste to original tracks with offset, also pastes section region when metadata present
- Regular `copyContainer` and `copyContainersInRange` clear section metadata from clipboard
- `RulerView`: drag-to-select bar range (DragGesture), click to clear selection, visual highlight on ruler
- `TimelineView`: translucent overlay across all tracks for selected range
- `TrackHeaderView`: `isTrackSelected` visual indicator (accent left border + tinted background)
- `MainContentView`: Cmd+click track headers to toggle track selection for copy filter
- Cmd+C: copies containers in selected range (with track filter) or single selected container
- Cmd+V: pastes clipboard at playhead position to original tracks
- Section "Copy Section" now uses `copySectionWithMetadata` — paste also creates section region
- 15 new tests: range copy within range, paste offset adjustment, section copy metadata, track filter, empty range, empty clipboard no-op, regular copy clears section metadata, range copy clears section metadata, multi-track paste skip overlap, empty filter includes all, paste creates independent containers, paste undo/redo, selected range default, set/clear range, toggle track selection
- All 375 tests pass

### Iteration 10 — #70 Storyline inspector: section-based song progression view
- New `StorylineDerivation` in LoopsCore: pure derivation of storyline entries from song sections + tracks
- `StorylineEntry`: section + per-track summaries with human-readable `summary` computed property
- `TrackActivitySummary`: track info + active containers in section range
- `ContainerActivitySummary`: container name, record arm state, enter/exit action descriptions, effect names, automation lane count
- Derivation scans all containers overlapping each section's bar range, aggregates MIDI actions (PC, CC, NoteOn/Off), trigger actions, setParameter actions
- Record-armed tracks appear in storyline even without active containers
- `StorylineInspectorView`: vertical scrollable list of section entries with colored badges and bar ranges
- Disclosure triangle expands per-section details: active containers per track, enter/exit actions, effects, automation lanes
- Editable notes field per section for performance reminders (e.g., "wait for crowd", "switch to clean tone")
- Sections without content shown as empty placeholders
- `MainContentView`: new `InspectorMode` enum (`.container` / `.storyline`) with segmented picker at top of inspector panel
- Container inspector and storyline inspector switch seamlessly via tab
- `SectionRegion.notes` field (already existed) wired to `setSectionNotes` (already existed) through UI
- 11 new tests: storyline derivation with actions, section with no containers, multi-track aggregation, notes Codable round-trip, sections sorted by startBar, container partial overlap included, container outside range excluded, record armed track appears, effects and automation reported, trigger actions summary, multiple sections mixed content
- All 386 tests pass

### Iteration 8 — #68 Context menus: right-click on containers, tracks, timeline & sections
- New `ClipboardContainerEntry` model: stores container + source trackID for copy/paste operations
- `ProjectViewModel`: clipboard (`[ClipboardContainerEntry]`, `clipboardBaseBar`) for container copy/paste
- `copyContainer(trackID:containerID:)`: copies single container to clipboard
- `copyContainersInRange(startBar:endBar:)`: copies all containers overlapping bar range (for section copy)
- `duplicateContainer(trackID:containerID:)`: creates independent copy at next available position with undo
- `duplicateTrack(trackID:)`: deep-copies track with all containers, properties, effects, MIDI routing with undo
- `pasteContainers(trackID:atBar:)`: pastes clipboard at target bar with offset calculation, skips overlapping
- `splitSection(sectionID:atBar:)`: splits section into two at given bar position with undo
- Container context menu: Copy, Duplicate, Link (Create Clone), Unlink (Consolidate, clone-only), Edit, Arm/Disarm, Delete
- Track header context menu: Rename, Duplicate Track, Arm/Disarm Recording, Input/Output/MIDI submenus, Delete Track (with confirmation for non-empty tracks)
- Timeline empty area context menu: Create Container Here, Paste (shown when clipboard non-empty)
- Section region context menu: Rename, Recolor (8-color submenu), Copy Section, Split at Playhead, Delete
- Callbacks wired through ContainerView → TrackLaneView → TimelineView → MainContentView
- 13 new tests: duplicate container, duplicate container overlap, duplicate track deep copy, duplicate track properties, duplicate track undo/redo, copy container to clipboard, paste at position with offset, paste skips overlap, copy section range, split section, split section at boundary fails, split section undo, clone state reflects parentContainerID
- All 360 tests pass

# ============================================================
# PRD #50: Container Effects, Enter/Exit Strategies (COMPLETE)
# Issues: #51-#59 (9 vertical slices) — all closed
# ============================================================

## Issue Dependency Graph
# #51 Container effect chain (tracer bullet) — no blockers
# #52 Container instrument override — blocked by #51
# #53 Crossfade engine — blocked by #51
# #54 Enter/exit MIDI actions — blocked by #51
# #55 Container triggers — blocked by #51, #54
# #56 Parameter snapshots — blocked by #51, #54
# #57 Time-based automation — blocked by #56
# #58 Container detail editor UI — blocked by #51, #54, #57
# #59 Offline rendering — blocked by #51, #53, #57

## Completed
### Iteration 1 — #51 Container effect chain: model + single AU + playback
- Added `insertEffects: [InsertEffect]` and `isEffectChainBypassed: Bool` to Container model
- Backward-compatible decoding (defaults to [] / false for old project files)
- Refactored PlaybackScheduler: per-container audio subgraph (AVAudioPlayerNode → [AU Effects] → Track AVAudioMixerNode → mainMixer)
- AU effects pre-instantiated during async prepare()
- Bypass routes audio directly to track mixer, skipping effects
- ContainerInspector shows effect names, per-effect bypass, chain bypass toggle, add/remove
- ProjectViewModel: add/remove/bypass container effects with full undo/redo
- Added Codable round-trip tests + legacy decode test
- All 181 tests pass

### Iteration 2 — #52 Container instrument override
- Added `instrumentOverride: AudioComponentInfo?` to Container model
- Backward-compatible decoding (defaults to nil for old project files)
- PlaybackScheduler builds subgraph: PlayerNode → [Instrument Override] → [AU Effects] → Track Mixer
- Instrument AU loaded and attached during async prepare(), cleaned up properly
- ContainerInspector shows instrument override name (MIDI tracks only) with set/remove controls
- AU instrument picker via Menu using AudioUnitDiscovery.instruments()
- ProjectViewModel.setContainerInstrumentOverride with full undo/redo
- Added selectedContainerTrackKind helper to show instrument section only on MIDI tracks
- Codable round-trip tests + legacy decode test updated
- All 183 tests pass

### Iteration 3 — #53 Crossfade engine: enter/exit audio fades
- Added `FadeSettings` model with `duration: Double` (bars) and `curve: CurveType` enum
- `CurveType` enum: `linear`, `exponential`, `sCurve` with `gain(at:)` curve math
- Added `enterFade: FadeSettings?` and `exitFade: FadeSettings?` to Container model
- Backward-compatible decoding (defaults to nil for old project files)
- PlaybackScheduler: buffer-based fade processing applies per-sample gain envelopes
- Fade-in ramps 0→1 at container start, fade-out ramps 1→0 at container end
- Efficient: only uses buffer path when fades present, otherwise unchanged scheduleSegment
- Handles both single-play and looping (.fill) containers
- ContainerInspector: fade toggles, duration sliders (0.25–16 bars), curve type pickers
- ProjectViewModel: setContainerEnterFade/setContainerExitFade with full undo/redo
- 9 new tests: Codable round-trip, curve math (known values, endpoints, monotonicity)
- All 192 tests pass

### Iteration 4 — #54 Enter/exit actions: MIDI output
- New models: `ContainerAction` enum (`.sendMIDI` case), `MIDIDestination` (`.externalPort`/`.internalTrack`), `MIDIActionMessage` (programChange, CC, noteOn, noteOff)
- Added `onEnterActions: [ContainerAction]` and `onExitActions: [ContainerAction]` to Container model
- Backward-compatible decoding (defaults to [] for old project files)
- `MIDIOutput` protocol for testable MIDI sending (external CoreMIDI + internal AU instrument)
- `CoreMIDIOutput`: real implementation using CoreMIDI output port + AUAudioUnit.scheduleMIDIEventBlock
- `ActionDispatcher`: receives container enter/exit events, executes MIDI actions via MIDIOutput protocol
- PlaybackScheduler: fires enter actions on play, exit actions on stop, tracks active containers
- ContainerInspector: enter/exit action list sections with add menus (PC, CC, NoteOn, NoteOff) and remove buttons
- ProjectViewModel: add/remove enter/exit actions with full undo/redo
- 22 new tests: Codable round-trip for all action types, backward-compat, ActionDispatcher with MockMIDIOutput, MIDI byte encoding
- All 214 tests pass

### Iteration 5 — #55 Enter/exit actions: container triggers
- New `TriggerAction` enum: `.start`, `.stop`, `.armRecord`, `.disarmRecord`
- Extended `ContainerAction` with `.triggerContainer(id:, targetID: ID<Container>, action: TriggerAction)` case
- `ContainerTriggerDelegate` protocol for testable trigger execution (start/stop/arm containers)
- `ActionDispatcher`: resolves triggerContainer actions via delegate, graceful no-op when delegate absent
- `PlaybackScheduler` conforms to `ContainerTriggerDelegate`: triggerStart schedules target container audio, triggerStop halts it, setRecordArmed forwards via callback
- PlaybackScheduler stores playback state (song, BPM, time sig, sample rate) for mid-playback trigger scheduling
- Refactored PlaybackScheduler.play() to use shared `scheduleContainer()` method (reused by triggerStart)
- ContainerInspector: accepts `allContainers` param, shows trigger actions with target name + action type, "Add Trigger Action" menu with target container picker and action sub-menu
- TransportViewModel: wires up ActionDispatcher + CoreMIDIOutput + triggerDelegate on scheduler creation
- ProjectViewModel: `allContainersInCurrentSong` computed property for target picker
- 14 new tests: TriggerAction Codable round-trip (all 4 cases), triggerContainer Codable round-trip (start/stop/arm/disarm), mixed action containers, ActionDispatcher trigger dispatch (start/stop/arm/disarm), no-delegate graceful handling, mixed MIDI+trigger ordering, multiple triggers
- All 228 tests pass

### Iteration 6 — #56 Parameter automation: snapshot values on enter/exit
- New `EffectPath` model: `trackID: ID<Track>`, `containerID: ID<Container>?` (nil = track-level), `effectIndex: Int`, `parameterAddress: UInt64`
- Extended `ContainerAction` with `.setParameter(id:, target: EffectPath, value: Float)` case
- `makeSetParameter(target:value:)` factory method with auto-generated ID
- New `ParameterResolver` protocol for testable parameter setting via `setParameter(at:value:)`
- `ActionDispatcher`: handles `.setParameter` actions via `parameterResolver` delegate, graceful no-op when resolver absent
- `PlaybackScheduler` conforms to `ParameterResolver`: resolves container-level EffectPath to live AUParameter via containerSubgraphs, sets value via `AUParameterTree`
- `TransportViewModel`: wires up `parameterResolver` on ActionDispatcher creation
- `ContainerInspector`: accepts `allTracks` param, displays parameter actions with target description (track → container → effect), "Add Parameter Action" menu with target picker flow (track → container/track-level → effect)
- `ProjectViewModel`: `allTracksInCurrentSong` computed property for target picker
- 12 new tests: EffectPath Codable round-trip (container-level + track-level), setParameter action round-trip, container with setParameter actions, mixed all-action-types, ActionDispatcher setParameter dispatch (enter/exit), no-resolver graceful handling, multiple parameter actions ordering, mixed MIDI+trigger+parameter, track-level path dispatch
- All 240 tests pass

### Iteration 7 — #57 Time-based automation envelopes
- New `AutomationBreakpoint` model: `position: Double` (bar offset within container), `value: Float`, `curve: CurveType`
- New `AutomationLane` model: `targetPath: EffectPath`, `breakpoints: [AutomationBreakpoint]`
- `interpolatedValue(atBar:)` engine: sorts breakpoints, interpolates between surrounding points using left breakpoint's curve
- Edge cases: no breakpoints → nil, single breakpoint → constant, before first / after last → clamp to nearest
- Added `automationLanes: [AutomationLane]` to Container model
- Backward-compatible decoding (defaults to [] for old project files)
- PlaybackScheduler: automation timer (~60 Hz) evaluates lanes during playback, applies interpolated values to AU parameters via `setParameter(at:value:)`
- Automation can target own effects, other containers' effects, or track-level effects (via EffectPath)
- ContainerInspector: "Automation Lanes" section with disclosure groups per lane, breakpoint list (position/value/curve), add/remove breakpoints, add lane from parameter target picker, remove lane
- ProjectViewModel: addAutomationLane, removeAutomationLane, addAutomationBreakpoint, removeAutomationBreakpoint, updateAutomationBreakpoint — all with full undo/redo
- MainContentView: wired up all 5 automation callbacks to ProjectViewModel
- 14 new tests: AutomationBreakpoint Codable round-trip, AutomationLane Codable round-trip, Container with automation lanes round-trip, Container without automation lanes (empty array), legacy decode (backward compat), interpolation with no breakpoints, single breakpoint, before first, after last, linear interpolation, exponential interpolation, S-curve interpolation, three-breakpoint interpolation, unsorted breakpoints
- All 254 tests pass

### Iteration 8 — #58 Container detail editor UI
- Refactored ContainerInspector into summary cards: effect names, action types, fade durations, automation lane count
- "Edit Container" button opens detail sheet (ContainerDetailEditor)
- Detail sheet with 4 tabs: Effects, Actions, Automation, Fades
- Effects tab: ordered effect list with drag-to-reorder (onMove), per-effect bypass toggle, AU browser grouped by manufacturer, instrument override picker (MIDI tracks only)
- Actions tab: enter/exit action lists with add/remove, MIDI/trigger/parameter sub-editors, container target picker, MIDI destination picker
- Automation tab: lane list with Grid-based breakpoint table editor, add/remove lanes and breakpoints
- Fades tab: enter/exit duration sliders, curve type pickers, visual FadeCurvePreview (Path-based curve rendering)
- Added `reorderContainerEffects(containerID:from:to:)` to ProjectViewModel with full undo/redo
- Double-click container on timeline opens detail editor (onDoubleClick callback through ContainerView → TrackLaneView → TimelineView → MainContentView)
- Return key opens detail editor for selected container (.onKeyPress(.return))
- All changes go through ProjectViewModel for undo/redo
- Detail editor respects current selection (reads from projectViewModel.selectedContainer)
- 7 new tests: reorder effects down, reorder effects up, reorder undo, invalid ID no-op, selectedContainer property, allContainersInCurrentSong, allTracksInCurrentSong
- All 261 tests pass

### Iteration 9 — #59 Offline rendering with container effects, fades & automation
- Extended OfflineRenderer to process container audio through AU effect chains offline
- Three-phase rendering: (1) pre-render containers with looping, fades, and effects, (2) process track-level effects, (3) mix into output
- Container effect processing uses AVAudioEngine in manual rendering mode per container
- Fade-in/fade-out gain curves applied to container buffers before effect processing (matching real-time signal flow)
- Automation lanes evaluated per-chunk during effect processing, targeting container's own AU parameters
- Instrument override AU loaded and used for containers that have one
- Bypassed effect chains render dry (effects skipped, matching real-time behavior)
- MIDI actions logged but not sent during offline render (no external hardware)
- Container trigger actions simulated: containers on muted tracks are included when triggered by audible containers
- Track-level effects processed via separate offline AVAudioEngine pass after container mixing
- `render()` method now `async` to support AU instantiation; ExportAudioView caller updated
- 6 new tests: enter fade gain ramp, exit fade gain ramp, bypassed chain renders dry, MIDI actions skipped, AU effect produces processed output (Apple Delay on impulse), trigger resolves container from muted track
- All 267 tests pass

# ============================================================
# PRD #71 (continued): Transport, Master Track, Mixer, MIDI Parameter Control
# ============================================================

### Iteration 4 — #75 Master track: effects chain, output selector & metronome zones
- Added `.master` case to `TrackKind` enum with `creatableKinds` static property excluding master
- Created `MetronomeSettings` and `MetronomeSubdivision` models for per-section click behavior
- Added `metronomeSettings: MetronomeSettings?` to Container for master track metronome zones
- Added `isEffectChainBypassed: Bool` to Track for track-level effect chain bypass
- Added `masterTrack` computed property, `ensureMasterTrack()`, `ensureMasterTrackLast()` to Song
- Updated ProjectViewModel: auto-creates master track on new/open/add song, prevents master delete/duplicate/move, ensures master always last
- Added master track management methods: addMasterEffect, removeMasterEffect, toggleMasterEffectChainBypass, setMasterOutputPort
- Updated PlaybackScheduler: routes all track mixers through master mixer → master effects → main mixer
- Updated OfflineRenderer: 5-phase rendering (container → track effects → pre-master mix → master effects → write), excludes master from audible tracks, applies master volume/pan
- Updated TrackHeaderView: master-specific appearance (gray color, no record arm/monitor buttons, output routing display)
- Updated MainContentView: add track menu uses creatableKinds, context menu hides delete/duplicate/record for master, adds output selector for master
- Fixed exhaustive switch cases in TrackLaneView and StorylineInspectorView
- All backward-compatible: new fields use decodeIfPresent with defaults
- 13 files changed, 630 insertions
- 20 new tests (MetronomeSettings/Subdivision Codable, master track auto-creation, always-last ordering, delete/duplicate prevention, creatableKinds, ensureMasterTrack idempotency, legacy JSON decode)
- All 432 tests pass

### Iteration 5 — #76 Metronome enhancements: volume, output routing & subdivision
- `MetronomeGenerator`: added `volume` property (0.0–1.0, default 0.8), `setVolume(_:)` with clamping, `setSubdivision(_:)` for click density control
- `MetronomeGenerator`: subdivision-aware audio rendering — accent on beat 1 (1500 Hz), regular beats (1000 Hz), subdivision clicks (800 Hz, softer amplitude)
- `MetronomeGenerator`: `clicksPerBar(subdivision:beatsPerBar:)` static helper for timing calculations
- New `MetronomeConfig` model: `volume: Float`, `subdivision: MetronomeSubdivision`, `outputPortID: String?` — stored per song
- `Song` gains `metronomeConfig: MetronomeConfig` (default values, backward-compatible decoding)
- `AudioEngineManager`: dedicated `metronomeMixer` node for output routing, `setMetronomeOutputPort(_:)` method
- `TransportViewModel`: `metronomeVolume`, `metronomeSubdivision`, `metronomeOutputPortID` properties with setters
- `TransportViewModel`: `applyMetronomeConfig(_:)` for bulk config sync, `activeSubdivision(atBar:)` reads MetronomeSettings from active master track containers
- Play and seek paths now apply volume and subdivision to metronome before enabling
- `ProjectViewModel`: `setMetronomeConfig(songID:config:)` with full undo/redo, `duplicateSong` copies metronomeConfig
- `ToolbarView`: metronome volume slider (60px), subdivision picker menu (all 5 modes), output port selector submenu
- `LoopsRootView`: wired metronome config callbacks, bidirectional sync between Song and TransportViewModel
- 30 new tests: MetronomeGenerator volume/clamping/enabled/subdivision/clicksPerBar, MetronomeConfig Codable round-trip/defaults/volume clamping/no-output-port, Song with/without metronomeConfig, subdivision timing (clicks per bar for all modes in 4/4, 3/4, 6/8), ProjectViewModel setMetronomeConfig/undo-redo/no-op/duplicateSong
- All 462 tests pass

### Iteration 6 — #77 Mixer view: track faders, pan, meters & master strip
- `MixerView`: new main mixer panel with horizontal scroll for regular track strips, fixed master strip on right with divider
- `MixerStripView`: enhanced with record arm button (red circle), monitor button (headphone icon), master track support (no arm/monitor, visual border differentiation), bidirectional volume/pan sync via `.onChange`
- `MainContentView`: `ContentMode` enum (`.timeline`/`.mixer`) with segmented picker, extracted `mainSplitView`, `sidebarContent`, `centerContent`, `inspectorPanel` to fix type-checker complexity
- `MainContentView`: `timelineContent(song:)` and `mixerContent(song:)` switch between views, Cmd+Shift+M keyboard shortcut toggles mode
- `MixerView` wired to ProjectViewModel: volume/pan/mute/solo/record-arm/monitor callbacks
- `AudioEngineManager`: master level metering via `installMasterLevelTap()` on mainMixerNode bus 0, `removeMasterLevelTap()` on stop, `peakLevel(from:)` static helper
- `AudioEngineManager`: `onMasterLevelUpdate` callback for real-time level reporting to `MixerViewModel`
- `LoopsAppEntry`: creates `MixerViewModel`, passes to `MainContentView`, wires master level tap on appear
- `ProjectViewModel`: added `selectedContainerTrack` computed property (returns Track containing selected container), simplified `selectedContainerTrackKind` to use it
- 14 new tests: setTrackVolume (basic, undo/redo, clamping 0.0–2.0), setTrackPan (basic, undo/redo, clamping -1.0–1.0), MixerViewModel (gainToDBString, dbToGain, updateLevel, updateMasterLevel), master track volume/pan, invalid track ID no-op
- All 488 tests pass

### Iteration 7 — #78 Track volume & pan automation on timeline
- `EffectPath`: added `trackParameterEffectIndex` (-1), `volumeAddress` (0), `panAddress` (1) sentinels for built-in track parameters
- `EffectPath`: `isTrackVolume`, `isTrackPan`, `isTrackParameter` computed properties; `trackVolume(trackID:)` and `trackPan(trackID:)` factory methods
- `Track`: added `trackAutomationLanes: [AutomationLane]` for track-level automation (volume/pan), backward-compatible decoding (defaults to [])
- `PlaybackScheduler`: automation timer now evaluates track-level automation lanes at ~60 Hz, applies interpolated volume (0..1 → 0..2) and pan (0..1 → -1..+1) to track mixer nodes
- `OfflineRenderer`: mixing phase resolves track volume/pan automation per-chunk via `resolveTrackVolume`/`resolveTrackPan` helpers
- `TimelineViewModel`: `automationLaneCount` includes track automation lanes
- `TimelineView`: `uniqueAutomationPaths` includes track-level lanes first; `deleteSelectedBreakpoint` checks track lanes
- `AutomationSubLaneView`: supports `trackAutomationLane` prop for full-timeline rendering via new `TrackAutomationSubLaneView`
- `TrackLaneView`: passes track automation lane to sub-lane view, new `onAddTrackBreakpoint`/`onUpdateTrackBreakpoint`/`onDeleteTrackBreakpoint` callbacks
- `TrackHeaderView`: `hasAutomation` checks track automation lanes
- `MainContentView`: "Track Automation" context menu on track headers (Add/Remove Volume Automation, Add/Remove Pan Automation), `automationPathLabel` returns "Volume"/"Pan" for track parameters
- `ProjectViewModel`: `addTrackAutomationLane`, `removeTrackAutomationLane`, `addTrackAutomationBreakpoint`, `removeTrackAutomationBreakpoint`, `updateTrackAutomationBreakpoint` — all with full undo/redo
- `duplicateSong` and `duplicateTrack` copy `trackAutomationLanes`
- 22 new tests: EffectPath sentinels (volume/pan creation, properties, Codable round-trip), Track Codable with/without trackAutomationLanes (backward compat), volume/pan interpolation, no automation nil, ProjectViewModel CRUD (add lane, remove lane, add/update/remove breakpoint), undo/redo (lane + breakpoint), TimelineViewModel lane count/height, duplicateSong/duplicateTrack copy, invalid ID no-op
- All 510 tests pass

### Iteration 8 — #79 Track inspector: effects, routing & automation panel
- `ProjectViewModel`: `selectedTrackID` and `selectedContainerID` now mutually exclusive via `didSet` observers — setting one clears the other
- `ProjectViewModel`: new `selectedTrack` computed property returns the track for the selected track ID
- `ProjectViewModel`: `addTrackEffect`, `removeTrackEffect`, `reorderTrackEffects`, `toggleTrackEffectBypass`, `toggleTrackEffectChainBypass` — all with full undo/redo, mirroring container effect methods
- `PlaybackScheduler`: per-track insert effect chains loaded during `prepare()` — route: trackMixer → [track effects] → outputTarget (master mixer or mainMixer)
- `PlaybackScheduler`: track effect units cleaned up in `cleanup()`, `ParameterResolver` now resolves track-level effect parameters
- New `TrackInspectorView`: Form-based inspector showing track name (editable), kind, effects chain (add/remove/bypass/open plugin UI), I/O routing, MIDI routing, volume/pan sliders, and automation lanes summary
- `MainContentView`: inspector panel auto-switches between `ContainerInspector` and `TrackInspectorView` based on selection context (container selected → container inspector, track selected → track inspector)
- `MainContentView`: clicking a track header sets `selectedTrackID` (non-Cmd click), wired all track effect callbacks
- 18 new tests: selectedTrackID/selectedContainerID mutual exclusion (both directions), selectedTrack property, selectedTrack nil, Track insertEffects Codable round-trip, addTrackEffect (basic, multiple, invalid ID), removeTrackEffect with reindex, reorderTrackEffects, toggleTrackEffectBypass, toggleTrackEffectChainBypass, undo/redo (add/remove/reorder/chain bypass), deselectAll clears both, selectTrackByIndex
- All 528 tests pass

### Iteration 9 — #80 MIDI Learn for effect parameters: CC → parameter mapping
- New `MIDIParameterMapping` model: `trigger: MIDITrigger`, `targetPath: EffectPath`, `minValue`/`maxValue` range, `scaledValue(ccValue:)` maps CC 0–127 to parameter range
- `Project` gains `midiParameterMappings: [MIDIParameterMapping]` with backward-compatible decoding (defaults to [])
- `MIDILearnTarget` enum: `.control(MappableControl)` for transport, `.parameter(EffectPath, minValue:, maxValue:)` for effect parameters
- `MIDILearnController`: extended with `startParameterLearning(for:minValue:maxValue:)`, `onParameterMappingLearned` callback, handles both control and parameter targets
- `MIDIDispatcher`: `updateParameterMappings(_:)` builds trigger→mapping lookup, `dispatch(_:ccValue:)` overload scales and emits parameter values, `onParameterValue: ((EffectPath, Float) -> Void)?` callback
- `MIDIManager`: added `onMIDICCWithValue: ((MIDITrigger, UInt8) -> Void)?` callback for CC events with value byte
- `ProjectViewModel`: full CRUD — `addMIDIParameterMapping`, `removeMIDIParameterMapping(mappingID:)`, `removeMIDIParameterMapping(forTarget:)`, `removeAllMIDIParameterMappings` — all with undo/redo
- `ProjectViewModel`: learn flow — `isMIDIParameterLearning`, `midiLearnTargetPath`, `startMIDIParameterLearn`, `completeMIDIParameterLearn`, `cancelMIDIParameterLearn`
- `TransportViewModel`: `setParameter(at:value:)` forwards to `PlaybackScheduler.setParameter` (ParameterResolver)
- Real-time signal chain: MIDIManager → MIDIDispatcher (parameter lookup + CC scaling) → TransportViewModel.setParameter → PlaybackScheduler (ParameterResolver) → AUParameter
- `TrackInspectorView`: context menu on effect rows ("MIDI Learn" / "Remove MIDI Mapping"), cyan dot indicator on mapped effects, "MIDI Mappings" section listing all track mappings with trigger→target display and remove buttons
- `MainContentView`: wired MIDI learn/remove callbacks and mapping state to inspector
- `LoopsAppEntry`: `setupMIDIParameterDispatch()` wires MIDIManager CC events → MIDIDispatcher, intercepts events during learn mode, syncs dispatcher mappings on change
- 20 new tests: MIDIParameterMapping Codable round-trip, CC scaling (0→min, 127→max, 64→midpoint), Project backward-compat decode, Project with mappings round-trip, ProjectViewModel CRUD (add/remove by ID/target/all), undo/redo (add/remove), multiple mappings, MIDIDispatcher parameter dispatch (mapped/unmapped/learn-mode), MIDILearnController parameter learning/cancel, learn flow integration, learn replaces existing mapping
- All 550 tests pass

### Iteration 10 — #81 Expression pedal quick-assign: per-track CC → volume/effect
- `Track` gains `expressionPedalCC: UInt8?` (default nil) and `expressionPedalTarget: EffectPath?` (nil = track volume)
- Backward-compatible decoding (both default to nil for old project files)
- `ProjectViewModel`: `assignExpressionPedal(trackID:cc:target:)` — stores pedal config on track, creates `MIDIParameterMapping` (volume gets 0–2.0 range, effects get 0–1.0), removes old mapping on reassign, with full undo/redo
- `ProjectViewModel`: `removeExpressionPedal(trackID:)` — clears track fields and removes corresponding mapping, with full undo/redo
- `TrackInspectorView`: "Expression Pedal" section showing status ("CC #11 → Volume" or "Not assigned"), remove button, "Assign Expression Pedal" menu with target picker (Track Volume or effect parameters) and CC picker (CC #1, #2, #4, #7, #11)
- `TrackHeaderView`: teal dial icon + "Exp" label indicator when expression pedal is assigned
- `MainContentView`: wired `onAssignExpressionPedal` and `onRemoveExpressionPedal` callbacks to ProjectViewModel
- `duplicateTrack` and `duplicateSong` copy `expressionPedalCC` and `expressionPedalTarget`
- 14 new tests: Codable round-trip (with target, without target, backward compat), assign to volume (creates mapping with correct trigger/target/range), custom CC number, assign to effect parameter, CC→volume scaling (0→0.0, 127→2.0), remove clears mapping, remove no-op, assign undo/redo, remove undo/redo, reassign replaces previous, duplicateTrack copies, duplicateSong copies
- All 564 tests pass

# ============================================================
# PRD #82: Inspector & Editing Polish
# ============================================================

## Issue Dependency Graph
# #83 Fix track selection gesture and highlight — no blockers
# #84 Mixer UI fixes: fader and pan drag areas — no blockers
# #85 Wall-time clock in transport and inspector — no blockers
# #86 AU effect plugin window sizing verification — no blockers
# #87 Track inspector: make routing and MIDI fields editable — blocked by #83
# #88 Container inspector inline editing — no blockers
# #89 Setlist entry inspector with transitions and fade-in — no blockers
# #90 Linked clip inspector: parent display and parameter diff — blocked by #88
# #91 Track reorder, delete, and creation context menu — blocked by #83
# #92 Master channel pinned to bottom in timeline and mixer — no blockers
# #93 Container fade handles with visual overlay — no blockers
# #94 Effect parameter automation on timeline — no blockers
# #95 MIDI instrument parameter automation (searchable) — blocked by #94
# #96 Audio import async with preview rectangle — no blockers
# #97 Playhead-audio sync fix — no blockers
# #98 Audio recording into armed containers — no blockers
# #99 MIDI monitoring: log view, activity dots, inspector badges — no blockers

## Completed
### Iteration 1 — #83 Fix track selection gesture and highlight
- Root cause: `trackHeaderWithActions()` checked `timelineViewModel.selectedTrackIDs.contains(track.id)` for visual highlight, but regular click set `projectViewModel.selectedTrackID` — these were never synchronized
- Fixed `MainContentView.trackHeaderWithActions()`: highlight now checks `projectViewModel.selectedTrackID == track.id` (the canonical single-select source of truth)
- `timelineViewModel.selectedTrackIDs` remains separate — it's the multi-select set for range copy filtering (Cmd+click)
- Added track selection to mixer: `MixerStripView` gains `isTrackSelected` + `onTrackSelect`, `MixerView` gains `selectedTrackID` + `onTrackSelect`
- `MixerStripView`: selected strip shows accent color background (15% opacity) + accent border stroke + click-to-select gesture
- `MainContentView.mixerContent()`: wired `selectedTrackID` and `onTrackSelect` to `projectViewModel.selectedTrackID`
- Both timeline and mixer now respond to the same selection state (`projectViewModel.selectedTrackID`)
- 2 new tests: selecting different track deselects previous (single-select model), selecting track sets selection and inspector shows track properties
- All 596 tests pass

### Iteration 2 — #84 Mixer UI fixes: fader and pan drag areas
- Replaced `FaderView` rotated `Slider` (24pt wide) with custom vertical `DragGesture` control (44pt wide)
- Custom fader: track background, accent-colored fill, draggable thumb (28pt wide), unity (0 dB) tick mark, immediate value updates on drag
- Replaced `PanKnobView` horizontal `Slider` (60pt) with custom horizontal `DragGesture` control (60pt wide, 22pt tall)
- Custom pan knob: center tick, accent-colored fill from center to thumb, circular draggable thumb, immediate value updates on drag
- Both controls use `@Binding var value: Float` for direct engine integration
- Both respond immediately to drag (not just on release) via `DragGesture(minimumDistance: 0).onChanged`
- `MixerStripView`: existing `onChange(of: track.volume/pan)` observers ensure UI reflects engine state changes (prevents drift)
- Updated `MixerStripView` track name label from fixed `frame(width: 60)` to `frame(maxWidth: 64)` to accommodate wider fader
- 4 new tests: fader drag propagation (rapid updates reflected immediately), engine volume state readback, pan drag propagation, engine pan state readback
- All 600 tests pass

### Iteration 3 — #85 Wall-time clock in transport and inspector
- New `WallTimeConverter` enum in LoopsCore/Position: pure utility for bar-position → wall-clock-seconds conversion
- `seconds(forBar:bpm:beatsPerBar:)` converts 1-based bar position to seconds using tempo and time signature
- `formatted(_:)` formats seconds as MM:SS.ms (two-digit hundredths)
- `formattedTime(forBar:bpm:beatsPerBar:)` convenience combines conversion and formatting
- `ToolbarView`: wall-time clock (MM:SS.ms) displayed next to existing "Bar X.X" position, updates in real-time during playback
- `ContainerInspector`: new "Time" row showing wall-time start and end positions (monospaced, MM:SS.ms — MM:SS.ms)
- `ContainerInspector`: added `bpm` and `beatsPerBar` parameters (with defaults) for time conversion
- `MainContentView`: passes `transportViewModel.bpm` and `transportViewModel.timeSignature.beatsPerBar` to ContainerInspector
- 16 new tests: bar 1 = 0s, 120/60/90/140 BPM conversions, 3/4 and 6/8 time signatures, fractional bar, below-bar clamping, formatted zero/65.5s/large/negative, formatted time convenience
- All 616 tests pass

### Iteration 4 — #86 AU effect plugin window sizing verification
- Root cause: `PluginWindow.loadPlugin` checked `preferredContentSize` synchronously after setting `contentViewController`, but many AU effect plugins report their preferred size asynchronously after the view is added to a window
- Added `sizeObservation: NSKeyValueObservation?` to `PluginWindow` — KVO observation on the view controller's `preferredContentSize`
- When the plugin's preferred size isn't immediately available, the window now observes for async updates and resizes when the plugin reports its actual size
- Extracted `applyPreferredSize(from:)` helper: checks `preferredContentSize` first, falls back to `view.fittingSize`, returns whether a valid size was applied
- KVO observation is one-shot: cleared after first successful resize, and cleaned up on window close
- Added `window(for:)` query method on `PluginWindowManager` for testing
- Both instrument and effect plugin windows now consistently resize to their preferred dimensions
- 3 new tests: effect plugin window opens with non-loading dimensions (AUDelay), two different effects open separate windows (AUDelay + AUReverb2), same plugin reuses existing window
- All 619 tests pass

### Iteration 5 — #87 Track inspector: make routing and MIDI fields editable
- Replaced read-only `Text` views in `TrackInspectorView` routing section with interactive `Menu` controls for I/O ports, MIDI device, and MIDI channel
- `inputPortPicker`: Menu listing available input ports from `SettingsViewModel`, "Default" option sets nil
- `outputPortPicker`: Menu listing available output ports, shared by audio and master tracks
- `midiDevicePicker`: Menu listing available MIDI input devices from `MIDIManager.availableInputDevices()`, "All Devices" option sets nil
- `midiChannelPicker`: Menu with Omni + channels 1–16 for MIDI track channel selection
- Replaced `inputPortName`/`outputPortName`/`midiDeviceName`/`midiChannelLabel` display-only string params with `availableInputPorts: [InputPort]`, `availableOutputPorts: [OutputPort]`, `availableMIDIDevices: [MIDIInputDevice]` for interactive selection
- Display names resolved locally: `inputPortDisplayName`, `outputPortDisplayName`, `midiDeviceDisplayName`, `midiChannelDisplayName` computed properties
- `MainContentView`: wired `onSetInputPort` → `projectViewModel.setTrackInputPort`, `onSetOutputPort` → `setTrackOutputPort`/`setMasterOutputPort`, `onSetMIDIInput` → `setTrackMIDIInput`
- `MainContentView`: passes `settingsViewModel?.inputPorts`, `settingsViewModel?.outputPorts`, `engineManager?.midiManager.availableInputDevices()` to inspector
- Track name, volume/pan sliders, effects chain (add/remove/reorder/bypass), expression pedal all already editable from previous iterations
- 9 new tests: set input port updates model, set output port updates model, add effect reflected in chain, input port undo/redo, output port undo/redo, set master output port, set MIDI input updates device and channel, clear input port sets nil, invalid track ID no-op
- All 628 tests pass

### Iteration 6 — #88 Container inspector inline editing
- Replaced read-only summary cards in `ContainerInspector` with inline editing components from `ContainerDetailEditor`
- Effects section: inline effect list with bypass/remove/plugin-UI buttons, "Add Effect" menu browser grouped by manufacturer, chain bypass toggle, instrument override picker (MIDI tracks)
- Actions section: split into "Enter Actions" and "Exit Actions" sections with full action list display, remove buttons, and add menus (MIDI, Trigger, Parameter actions)
- Fades section: split into "Enter Fade" and "Exit Fade" sections with enable toggle, duration slider (0.25–16 bars), curve type picker, `FadeCurvePreview` visualization
- Automation section: inline automation lane list with disclosure groups, breakpoint tables (position/value/curve), add/remove breakpoints, add/remove lanes via parameter picker sheet
- Added `containerTrack: Track` parameter to `ContainerInspector` for automation target resolution
- Added `onUpdateEffectPreset` callback for plugin window preset changes
- Added fade state (`enterFadeEnabled/Duration/Curve`, `exitFadeEnabled/Duration/Curve`), effect browser state, and automation/parameter picker sheet state
- `MainContentView`: passes `containerTrack` and `onUpdateEffectPreset` to inspector
- "Open Detail Editor" button retained for full-screen editing access
- 8 new tests: toggle effect bypass, set enter fade, set exit fade, clear fade, fade undo/redo, add/remove enter action, add/remove automation lane, toggle effect chain bypass
- All 636 tests pass

### Iteration 7 — #89 Setlist entry inspector with transitions and fade-in
- `SetlistEntry`: added `fadeIn: FadeSettings?` property with backward-compatible decoding (`decodeIfPresent`, defaults to nil)
- `SetlistViewModel`: added `selectedSetlistEntryID: ID<SetlistEntry>?` for entry selection, `selectedSetlistEntry` computed property
- `SetlistViewModel`: added `updateFadeIn(entryID:fadeIn:)` method to set/clear fade-in settings
- New `SetlistEntryInspectorView`: Form-based inspector with three sections (Song info, Transition to Next, Fade In)
- Transition section: mode picker (Manual / Automatic / Automatic with Delay) mapping to existing `TransitionMode` enum, delay duration slider visible for automatic-with-delay mode
- Fade-in section: enable toggle, duration slider (0.25–16 bars), curve type picker (Linear/Exponential/S-Curve), `FadeCurvePreview` visualization
- `TransitionModeKind` UI enum maps between UI picker values and model's `TransitionMode` (manual↔manualAdvance, automatic↔seamless, automaticWithDelay↔gap)
- `SetlistEntryListView`: click-to-select on entry rows with accent highlight on selected entry
- `MainContentView`: inspector panel shows `SetlistEntryInspectorView` when a setlist entry is selected (after container/track inspector fallthrough)
- 9 new tests: SetlistEntry with fadeIn round-trip, backward-compat without fadeIn, all transition modes with fadeIn, selected setlist entry property, selected entry nil without setlist, update fade in, clear fade in, transition mode all cases, invalid entry ID no-op
- All 645 tests pass

### Iteration 8 — #90 Linked clip inspector: parent display and parameter diff
- New `LinkedClipInspectorView`: shows parent container reference (name, bar position) and field-by-field override diff for linked clones
- `ContainerField`: added `displayName` computed property returning human-readable names for all 8 field cases
- `ContainerInspector`: added `parentContainer: Container?` and `onNavigateToParent` callback parameters; shows `LinkedClipInspectorView` section at top of form when container `isClone`
- Parent reference row: link icon, parent name + bar range, clickable arrow button navigates to parent container
- Parameter diff list: iterates `ContainerField.allCases`, shows override status with orange "Overridden" badge (pencil icon) or gray "Inherited" badge (arrow icon) for each field
- Missing parent handled gracefully: warning icon + "Parent container not found" text
- `MainContentView`: wired `onNavigateToParent` to set `selectedContainerID` to parent, passes resolved `parentContainer` via `findContainer(id:)`
- 8 new tests: linked clip no overrides (all inherited), linked clip with overrides (correct diff), parent resolution (name/position), navigate to parent (selection), ContainerField displayNames, multiple overrides tracking, clone resolution inheritance, missing parent returns nil
- All 653 tests pass

### Iteration 9 — #91 Track reorder, delete, and creation context menu
- `ProjectViewModel`: new `insertTrack(kind:atIndex:)` method — inserts at specific position, clamps to array bounds, ensures master stays last, with full undo/redo
- `MainContentView`: drag-to-reorder on track headers via `.onDrag` / `.onDrop` with `TrackDropDelegate` — master track cannot be dragged, drop targets exclude master
- `MainContentView`: `draggingTrackID` state tracks active drag with 40% opacity visual feedback on dragged header
- `TrackDropDelegate`: `DropDelegate` implementation handles `dropEntered` for live reorder, `performDrop` to clear drag state, `validateDrop` to reject master targets
- `MainContentView`: context menu on empty space below track list — "Insert Audio Track", "Insert MIDI Track", etc. for all `TrackKind.creatableKinds`, inserts above master
- `MainContentView`: bottom padding (at least 80pt empty space) via `Color.clear` with `contentShape(Rectangle())` for context menu hit target
- `trackListContentHeight(song:)` helper computes total track header height for bottom padding calculation
- Existing context menu on track headers retained: Rename, Duplicate, Arm/Disarm, I/O routing, MIDI routing, Track Automation, Delete Track (with confirmation for non-empty)
- 9 new tests: reorder updates model order, master cannot be moved, reorder undo/redo, delete removes from song, delete master prevented, insert at specific index, insert at end above master, insert undo/redo, insert master prevented
- All 662 tests pass

### Iteration 10 — #92 Master channel pinned to bottom in timeline and mixer
- `TimelineView`: added `tracks: [Track]` parameter (defaults to `song.tracks`) — allows rendering a subset of tracks while keeping full song context for deletion searches
- `TimelineView`: `totalContentHeight` and `ForEach` use `tracks` instead of `song.tracks`
- `MainContentView.timelineContent`: splits `song.tracks` into `regularTracks` (scrollable) and `masterTrack` (pinned)
- `MainContentView`: regular track headers and TimelineView rendered inside `ScrollView(.vertical)`, master excluded
- `MainContentView`: master track header + lane rendered below scroll area in fixed `HStack` with its own horizontal `ScrollView`
- `MainContentView`: `Divider` between scrollable area and pinned master for visual separation
- `MainContentView`: renamed `trackListContentHeight` to `regularTrackListContentHeight`, filters out master for correct empty-space calculation
- Mixer already had master strip fixed on the right (outside horizontal ScrollView) with Divider — no changes needed
- 4 new tests: TimelineView with explicit tracks uses those tracks for height, song regular tracks exclude master, TimelineView defaults to all tracks, mixer separates regular and master
- All 666 tests pass

### Iteration 11 — #93 Container fade handles with visual overlay
- `ContainerView`: new `FadeOverlayShape` (Shape) renders semi-transparent gain-reduction overlay on container body for enter/exit fades
- `FadeOverlayShape`: draws filled paths representing the silence region above the fade curve for all three curve types (linear, exponential, s-curve)
- `FadeOverlayShape`: supports live drag preview via `enterFadeDragWidth`/`exitFadeDragWidth` overrides
- `ContainerView`: draggable fade handles at top-left (fade-in) and top-right (fade-out) corners — white circles with shadow
- Handles appear on hover or when a fade is active; horizontal drag adjusts fade duration in bars (snapped to 0.25-bar increments)
- Dragging below 0.125 bars removes the fade entirely; minimum settable duration is 0.25 bars
- Drag preserves existing curve type; new fades default to linear
- `ContainerView`: new `onSetEnterFade`/`onSetExitFade` callbacks wired through `TrackLaneView` → `TimelineView` → `ProjectViewModel`
- Inspector and drag handles stay in sync: both call `setContainerEnterFade`/`setContainerExitFade` on ProjectViewModel
- 10 new tests: fade handle enter/exit duration, drag-to-zero removes fade, preserve curve type, FadeOverlayShape paths for enter/exit/all curves/empty/drag override, FadeSettings serialization round-trip with various durations
- All 676 tests pass

### Iteration 12 — #94 Effect parameter automation on timeline
- `EffectPath`: added `isTrackEffectParameter` computed property — true when containerID is nil and effectIndex >= 0 (distinguishes effect parameters from volume/pan sentinels)
- `MainContentView`: extended "Track Automation" context menu with effect parameter entries grouped by effect name from track's insert chain
- `MainContentView`: added `pendingTrackAutomationLane` state + `ParameterPickerView` sheet for async AU parameter discovery and selection
- `MainContentView`: effect entries show "Add Parameter..." submenu when lanes already exist for that effect, with per-lane remove options
- `MainContentView`: updated `automationPathLabel` to show effect display name + parameter address for track effect parameter paths
- `PlaybackScheduler`: automation timer now evaluates track-level effect parameter automation at ~60 Hz — resolves EffectPath to captured `trackEffectUnits` and sets AU parameter values via `parameterTree`
- `OfflineRenderer`: `processTrackThroughEffects` now accepts `samplesPerBar` and evaluates effect parameter automation lanes per-chunk during offline rendering
- `OfflineRenderer`: maintains sorted effect index → AVAudioUnit mapping to correctly resolve automation paths to loaded AU instances
- Automation sublanes for effect parameters render using existing `TrackAutomationSubLaneView` (full-timeline span) — no view changes needed
- 10 new tests: isTrackEffectParameter identification (positive/negative cases), EffectPath Codable round-trip, effect parameter interpolation, ProjectViewModel add/remove/update breakpoints CRUD, undo/redo, Track Codable with mixed lanes, TimelineViewModel lane count, multiple effect lanes, duplicateTrack copies effect parameter lanes
- All 686 tests pass

### Iteration 13 — #95 MIDI instrument parameter automation (searchable)
- `EffectPath`: added `instrumentParameterEffectIndex` sentinel (-2) for track instrument parameters, `isTrackInstrumentParameter` computed property, `trackInstrument(trackID:parameterAddress:)` factory method
- `AudioUnitDiscovery`: added `groupName` field to `AudioUnitParameterInfo`, extracted from AU parameter tree group hierarchy
- `ParameterPickerView`: search now matches both display name and group name, parameter rows show group name subtitle
- `MainContentView`: extended "Track Automation" context menu with "Instrument" section for MIDI tracks with an `instrumentComponent`, supports add/remove instrument parameter lanes via `ParameterPickerView` sheet
- `MainContentView`: updated `automationPathLabel` to show "Instrument P{address}" for instrument parameter paths
- `PlaybackScheduler`: automation timer builds per-track instrument unit list from container subgraphs, evaluates `isTrackInstrumentParameter` lanes at ~60 Hz by setting parameter values on all container instrument units for the track
- `PlaybackScheduler`: `ParameterResolver.setParameter` handles instrument parameter paths by applying value to all container instrument units on the track
- `OfflineRenderer`: `processContainerThroughEffects` accepts `trackInstrumentLanes` parameter, evaluates track-level instrument automation per-chunk using absolute bar positions mapped to container-relative offsets
- `OfflineRenderer`: container-level automation also handles instrument parameter sentinel (effectIndex == -2) targeting the container's own instrument unit
- Instrument automation sublanes render using existing `TrackAutomationSubLaneView` (full-timeline span) — no view changes needed
- 12 new tests: isTrackInstrumentParameter identification (positive/negative for all path types), factory method, Codable round-trip, interpolation, ProjectViewModel add/CRUD/undo-redo, Track Codable with mixed lanes, TimelineViewModel lane count, duplicateTrack copies, mixed instrument+effect+volume lanes coexistence, search filtering by name and group
- All 698 tests pass

### Iteration 14 — #96 Audio import async with preview rectangle
- `AudioImporter`: new `AudioFileMetadata` struct for lightweight header-only metadata
- `AudioImporter`: new `readMetadata(from:)` static method — reads sample rate, sample count, channel count from audio file header without decoding samples (fast, safe for main thread)
- `AudioImporter`: new `importAudioFile(from:to:)` method — file copy only (no peak generation), returns `SourceRecording` with nil peaks
- `AudioImporter`: existing `importAudio(from:to:)` refactored to use `importAudioFile` + synchronous peak generation (backward compatible)
- `WaveformGenerator`: new `generatePeaksProgressively(from:batchSize:onProgress:)` — generates peaks in batches, calls `@Sendable` progress callback with accumulated peaks after each batch for progressive UI updates
- `ProjectViewModel`: new `importAudioAsync(url:trackID:startBar:audioDirectory:)` — reads metadata synchronously to create correctly-sized preview container immediately, then runs file copy + progressive peak generation on `Task.detached` background thread
- Preview container appears instantly at drop position with correct bar length (calculated from audio duration + tempo)
- Waveform peaks render progressively as background task generates them (via `@Observable` model updates)
- `TimelineViewModel`: new `ensureBarVisible(_:)` — expands `totalBars` if imported container extends beyond visible area (auto-scroll)
- `TimelineView`: drop handler updated to call `importAudioAsync` and `ensureBarVisible` for auto-scroll on import
- 12 new tests: readMetadata correct duration/sampleRate, readMetadata different sample rates, importAudioFile no peaks, progressive peaks match complete, progressive callback frequency, ensureBarVisible expands, ensureBarVisible no shrink, ensureBarVisible at boundary, importAudioAsync creates container immediately, importAudioAsync nil peaks initially, importAudioAsync rejects overlap, importAudioAsync selects container
- All 710 tests pass

### Iteration 15 — #97 Playhead-audio sync fix
- Root cause: `TransportViewModel.play()` called `transport.play()` synchronously (starting the wall-clock playhead timer) while audio scheduling ran in an async Task — playhead moved before audio started
- `TransportManager`: added `isWaitingForAudioSync` flag — when true, `tick()` holds playhead at current position (callbacks still fire, but position doesn't advance)
- `TransportManager`: added `play(waitForAudioSync:)` parameter — sets the flag and defers `playbackStartTime` capture until sync completes
- `TransportManager`: added `beginWaitForAudioSync()` for count-in → recording transition
- `TransportManager`: added `completeAudioSync(audioOutputLatency:)` — resets `playbackStartTime` accounting for hardware output latency, clears flag
- `TransportManager`: `tick()` uses `max(0, elapsed)` clamp so latency compensation holds playhead at start until audio reaches speakers
- `TransportManager`: `pause()` and `stop()` clear `isWaitingForAudioSync`
- `TransportViewModel.play()`: non-count-in path uses `transport.play(waitForAudioSync: true)`, count-in and no-engine paths use `transport.play()` (no wait)
- `TransportViewModel.schedulePlayback()`: after `scheduler.play()`, calls `transport.completeAudioSync(audioOutputLatency:)` with `engine.outputNode.presentationLatency`
- `TransportViewModel.seek(toBar:)`: uses `transport.play(waitForAudioSync: true)` for re-seek during playback
- `TransportViewModel` count-in completion: calls `transport.beginWaitForAudioSync()` before scheduling, `completeAudioSync` called by the async task
- 11 new tests: sync flag on play, completeAudioSync clears flag, latency holds playhead, no-op when not waiting, pause/stop clear flag, beginWaitForAudioSync, arbitrary start position, backward compat (no sync flag), completeAudioSync sets start bar, pause/resume during sync
- All 721 tests pass

### Iteration 16 — #98 Audio recording into armed containers
- New `ContainerRecorder` engine class: captures audio from engine input node into armed containers during playback
- `ContainerRecorder`: tracks playhead bar position from accumulated sample count, starts/stops recording as playhead enters/leaves armed container bar ranges
- `ContainerRecorder`: generates waveform peaks incrementally from captured samples (~100 peaks/sec) and reports via `onPeaksUpdated` callback
- `ContainerRecorder`: finalizes recording with `SourceRecording` metadata (filename, sample rate, sample count, peaks) via `onRecordingComplete` callback
- `TransportViewModel`: added `containerRecorder` property, `startContainerRecordingIfNeeded` / `stopContainerRecording` methods
- `TransportViewModel`: recording starts after audio scheduling in `schedulePlayback`, stops on pause/stop/seek
- `TransportViewModel`: `onRecordingPeaksUpdated` and `onRecordingComplete` callbacks for UI integration
- `ProjectViewModel`: added `liveRecordingPeaks` dictionary for in-progress recording waveform display
- `ProjectViewModel`: `updateRecordingPeaks(containerID:peaks:)` stores live peaks during recording
- `ProjectViewModel`: `waveformPeaks(for:)` returns live peaks during recording, falls back to SourceRecording peaks
- `ProjectViewModel`: `setContainerRecording` clears live peaks when recording completes
- `ContainerView`: armed containers show red border (2px) and red-tinted background
- `ContainerView`: armed containers show red filled circle icon next to container name
- `LoopsRootView`: wired `onRecordingPeaksUpdated` → `updateRecordingPeaks` and `onRecordingComplete` → `setContainerRecording`
- 10 new tests: armed state serialization round-trip, armed defaults false, CAF writer produces valid readable file, recording duration matches bar range (120 BPM/4 bars = 352800 samples), set recording clears live peaks, live peaks shown during recording, container record arm undo/redo, peaksFromSamples correctness, samplesPerBar calculation, armed visual state persists through encode/decode
- All 731 tests pass

### Iteration 17 — #99 MIDI monitoring: log view, activity dots, inspector badges
- `MIDIManager`: added `onRawMIDIMessage: ((UInt32, String?) -> Void)?` callback — fires for every received MIDI word before existing dispatch
- `MIDIManager`: `parseMessage` now handles NoteOff (0x80), Program Change (0xC0), Pitch Bend (0xE0) in addition to existing NoteOn and CC
- New `MIDILogMessage` enum in LoopsCore: `.noteOn`, `.noteOff`, `.controlChange`, `.programChange`, `.pitchBend`, `.other` with `displayString` (note names like "C4", CC names like "Sustain")
- New `MIDILogEntry` model: `id`, `timestamp`, `deviceID`, `deviceName`, `channel`, `message` with `fromRawWord(_:deviceID:deviceName:)` factory for parsing raw MIDI words
- `MIDILogMessage.noteName(_:)` static helper: MIDI note number → "C4", "D#5" etc.
- `MIDILogMessage.ccName(_:)` static helper: CC number → "Sustain", "Modulation", "Volume" etc. for common controllers
- New `MIDIActivityMonitor` (`@Observable @MainActor`): taps into MIDIManager raw callback, maintains circular buffer (~500 entries) of `MIDILogEntry`, per-track activity tracking via `MIDITrackFilter.matches()` with ~300ms activity window
- `MIDIActivityMonitor`: `recordMessage(word:deviceID:)`, `isTrackActive(_:)`, `clearLog()`, `clearAll()`, `isPaused` (pauses log but still tracks activity), `updateTracks(_:)`, `updateDeviceNames(_:)`
- New `MIDILogWindowManager`: singleton floating NSWindow manager for MIDI log view (reuses PluginWindowManager pattern)
- New `MIDILogView`: scrolling table with timestamp, device, channel, message columns; device and channel filter dropdowns; clear and pause buttons; auto-scrolls to bottom
- `TrackHeaderView`: added `isMIDIActive: Bool` parameter — small green circle next to MIDI track names with 300ms fade animation, only visible on `.midi` kind tracks
- `ContainerInspector`: added `isMIDIActive: Bool` and `playheadBar: Double` parameters — green "MIDI" pill badge near container name when track has MIDI activity AND playhead is within container's bar range
- `MainContentView`: added `midiActivityMonitor: MIDIActivityMonitor?` parameter, passes `isMIDIActive` to TrackHeaderView and ContainerInspector, Cmd+Shift+L keyboard shortcut toggles MIDI log window
- `LoopsRootView`: creates `MIDIActivityMonitor`, wires `onRawMIDIMessage` to monitor, passes to MainContentView, syncs tracks on song change
- 30 new tests: MIDILogEntry note names (C4/D#5/A0/C-1/G9), CC names (Sustain/Modulation/Volume/Expression/unknown), display strings (all message types), fromRawWord parsing (NoteOn/NoteOff/NoteOn-vel0-as-NoteOff/CC/PC/PitchBend), MIDIActivityMonitor circular buffer, buffer eviction, per-track activity matching, omni channel, activity expiration, pause stops logging but tracks activity, clear log, device name lookup, multiple message types
- All 761 tests pass

### Iteration 18 — #100 Setlist sidebar: highlight current entry and show song progress
- `SetlistViewModel`: added `updateSongProgress(playheadBar:songLengthBars:)` — converts playhead position to 0.0–1.0 progress, clamped, only active during perform mode
- `SetlistViewModel`: added `activeSectionID(atBar:)` — returns the section region containing the current playhead position for the current perform song
- `SetlistEntryListView`: current entry (matching `currentEntryIndex` during perform mode) gets accent background highlight (25% opacity), play icon, and bold font
- `SetlistEntryListView`: progress bar shown on current entry — thin accent-colored bar fill proportional to `currentSongProgress`
- `SetlistEntryListView`: section regions displayed under song name when song has sections — colored dots with section names, active section gets tinted background
- `SetlistEntryListView`: added `playheadBar` parameter for section activity tracking, `entryIndex(for:)` helper for index lookup
- `SetlistSidebarView`: added `playheadBar` parameter, passes through to `SetlistEntryListView`
- `MainContentView`: passes `timelineViewModel.playheadBar` to `SetlistSidebarView` for real-time section tracking
- `LoopsRootView`: extended `onPlayheadChanged` callback to update `setlistViewModel.updateSongProgress` during perform mode using computed song length
- Highlighting clears automatically when exiting perform mode (progress update returns 0 when `isPerformMode` is false)
- 7 new tests: advance updates index and resets progress, progress calculation at various positions (0/middle/end/beyond/before), progress zero outside perform mode, progress zero for empty song, active section ID tracks playhead, highlight clears on exit perform mode, previous song resets progress
- All 768 tests pass

### Iteration 19 — #101 AU effect plugin: live parameter updates to running engine
- Root cause: `PluginWindow.loadPlugin()` created a separate `AVAudioUnit` via `AVAudioUnit.instantiate()` — this standalone instance was not connected to the engine's audio graph, so parameter changes had no effect on live audio
- `PlaybackScheduler`: added `liveEffectUnit(containerID:effectIndex:)`, `liveTrackEffectUnit(trackID:effectIndex:)`, `liveMasterEffectUnit(effectIndex:)` — thread-safe lookups into `containerSubgraphs`, `trackEffectUnits`, and `masterEffectUnits` dictionaries
- `TransportViewModel`: forwarding methods `liveEffectUnit`, `liveTrackEffectUnit`, `liveMasterEffectUnit` delegate to PlaybackScheduler
- `PluginWindow`: refactored into two-path initialization — when `liveAudioUnit` is provided (engine's active instance), the window displays that AU's view controller directly; when nil, falls back to standalone instantiation with preset restore
- `PluginWindow`: extracted `presentAudioUnit(_:displayName:)` (shared UI presentation) and `loadStandalonePlugin(component:presetData:displayName:)` (fallback creation)
- `PluginWindowManager.open()`: added `liveAudioUnit: AVAudioUnit?` parameter (default nil) for backward compatibility
- `ContainerInspector`: added `liveEffectUnit: ((Int) -> AVAudioUnit?)?` callback, passes live AU to `PluginWindowManager.shared.open()` for container effects
- `ContainerDetailEditor`: added `liveEffectUnit: ((Int) -> AVAudioUnit?)?` callback, passes live AU for detail editor effect list
- `TrackInspectorView`: added `liveTrackEffectUnit: ((Int) -> AVAudioUnit?)?` callback, passes live AU for track effects
- `MainContentView`: wired `liveEffectUnit` (container effects via `transportViewModel?.liveEffectUnit`) and `liveTrackEffectUnit` (track effects via `transportViewModel?.liveTrackEffectUnit`) to inspector views
- Preset saving works for both live and standalone instances (window close saves from whichever AU was used)
- 9 new tests: PlaybackScheduler (liveEffectUnit returns container effect after prepare, liveTrackEffectUnit returns track effect, nil for invalid container ID, nil for out-of-bounds index, nil after cleanup, parameter change on live unit is reflected, preset data round-trips through engine instance), PluginWindow (live AU uses engine instance, fallback to standalone)
- All 777 tests pass

### Iteration 20 — #102 Song switching: reset playhead and apply song immediately
- `ProjectViewModel`: added `onSongChanged` callback, fired in `selectSong(id:)` only when song ID actually changes (not on same-song re-selection)
- `TransportViewModel`: added `handleSongChanged()` — pauses transport if playing/counting-in, resets playhead to bar 1, clears lastPreparedSong/lastPreparedRecordingIDs to force audio graph rebuild, calls `play()` to restart playback if it was active
- `LoopsRootView`: wired `viewModel.onSongChanged` to `transportViewModel.handleSongChanged()` in onAppear
- Sidebar song selection (SongListView tap) and setlist navigation (advanceToNextSong/goToPreviousSong) both trigger the same song-change flow via `selectSong(id:)`
- Setlist perform mode transitions work correctly: transition modes (seamless, gap, manual) control when advance triggers; the playback restart is handled uniformly
- If playback was stopped when switching songs, only the playhead resets to bar 1 (no playback starts)
- 8 new tests: selectSong fires onSongChanged, same song no callback, handleSongChanged resets playhead, handleSongChanged restarts playback, handleSongChanged while stopped no playback, setlist advance triggers callback, setlist previous triggers callback, sidebar switch triggers callback
- All 785 tests pass

### Iteration 21 — #103 Return-to-start-position on stop (configurable, default on)
- `TransportManager`: added `returnToStartEnabled: Bool` (default true) and `userPlayStartBar: Double` (records where user pressed play)
- `TransportManager`: `play()` now records `userPlayStartBar = playheadBar` before starting playback (both normal and count-in paths)
- `TransportManager`: `stop()` modified — when `returnToStartEnabled` is true and playhead has moved past start position, returns to `userPlayStartBar`; when already at start position (double-stop), returns to bar 1; when disabled, always returns to bar 1
- `TransportViewModel`: added `returnToStartEnabled: Bool` persisted via UserDefaults (key: "returnToStartEnabled", default true)
- `TransportViewModel`: added `isPerformMode: Bool` — when true, return-to-start is bypassed in `stop()` (always goes to bar 1)
- `TransportViewModel`: `stop()` syncs `transport.returnToStartEnabled = returnToStartEnabled && !isPerformMode` before calling `transport.stop()`
- `ToolbarView`: return-to-start toggle button (arrow.uturn.backward icon) next to stop button, accent-colored when enabled, secondary when disabled
- `LoopsRootView`: wired `.onChange(of: setlistViewModel?.isPerformMode)` to sync `transportViewModel.isPerformMode`
- 14 new tests: stop returns to start position (enabled), double-stop returns to bar 1, stop returns to bar 1 (disabled), default is true, stop from bar 1, userPlayStartBar set on play, pause-then-play sets new start bar, bypassed via property, count-in records start bar, TransportViewModel stop returns to start, TransportViewModel stop disabled, TransportViewModel perform mode bypass, TransportViewModel perform mode off
- All 798 tests pass

# ============================================================
# PRD #105: UX Refinements & Live Looping
# ============================================================

## Completed
### Iteration 1 — #104 Linked container recording propagation: record once, play in all linked copies
- `ContainerField`: `.sourceRecording` case already present for clone override tracking
- `Container.resolved(parent:)`: already inherits `sourceRecordingID` when `.sourceRecording` not in `overriddenFields`; fixed misleading doc comment
- `PlaybackScheduler.prepare()`: already pre-allocates subgraphs for linked clones without audio (line 173: `guard hasAudio || isLinkedClone`)
- `PlaybackScheduler.registerRecording(id:file:)`: already exists for mid-session audio file registration
- `PlaybackScheduler.scheduleLinkedContainer(container:)`: already exists for mid-session linked container scheduling
- `ProjectViewModel.setContainerRecording()`: already propagates recording to clones (via `parentContainerID`) and link group members (via `linkGroupID`), marks `.sourceRecording` as overridden when recording into a clone, fires `onRecordingPropagated` callback
- `TransportViewModel.registerAndScheduleLinkedContainers()`: NEW — loads audio file from disk, registers with running scheduler, schedules all linked containers for playback
- `ProjectViewModel.updateRecordingPeaks()`: UPDATED — now propagates live waveform peaks to all linked containers (clones and link group members) that don't override `.sourceRecording`
- `ProjectViewModel.setContainerRecording()`: clears live peaks for both the recorded container and all linked containers on completion
- `LoopsAppEntry`: already wires `onRecordingPropagated` → `registerAndScheduleLinkedContainers`
- 13 new tests: clone inherits sourceRecordingID, clone overrides sourceRecordingID, clone inherits nil sourceRecording, ContainerField.sourceRecording displayName, recording propagates via parentContainerID, recording propagates via linkGroup, recording override isolation, recording into clone marks overridden, onRecordingPropagated callback fires, live peaks propagate to linked containers, live peaks don't propagate to overridden clone, setContainerRecording clears live peaks, no propagation to unrelated containers
- All 811 tests pass

### Iteration 2 — #106 Keyboard shortcut focus management
- New `FocusedField` enum with `.main` case to track whether main content area has keyboard focus
- Replaced `@FocusState private var isMainFocused: Bool` with `@FocusState private var focusedField: FocusedField?` on `MainContentView`
- Computed `isTextFieldFocused` property: returns true when `focusedField != .main` (nil means a text field or non-main view has focus)
- Guarded all single-key `.onKeyPress` handlers (Space, Return, R, M, Left, Right, Home, End, 1-9, Tab) with `guard !isTextFieldFocused else { return .ignored }` — allows normal typing in text fields
- Modifier-key shortcuts (Cmd+C, Cmd+V, Cmd+D, Cmd+A, Cmd+Shift+M, Cmd+Shift+L) NOT guarded — OS handles Cmd+key in text fields separately
- Escape key: when text field focused, restores focus to `.main` (returns to shortcut mode); when main focused, performs deselect-all as before
- `.focusScope(inspectorNamespace)` applied to inspector panel container for proper focus scoping
- SwiftUI focus mechanism: when a TextField in a child view (ContainerInspector, TrackInspectorView, StorylineInspectorView) gains focus, `focusedField` naturally becomes `nil` because focus leaves the `.main`-bound view
- 10 new tests: FocusedField enum, Hashable conformance, MainContentView creation, shortcut model test, escape deselect, nil-means-text-field-active logic, shortcut guard documentation, ContentMode/InspectorMode/SidebarTab enums unchanged
- All 821 tests pass

### Iteration 3 — #107 Undo/Redo toolbar buttons
- `ToolbarView`: added `onUndo`/`onRedo` callbacks, `canUndo`/`canRedo` disabled state, `undoActionName`/`redoActionName` for tooltips
- `ToolbarView`: undo button (`arrow.uturn.backward`) and redo button (`arrow.uturn.forward`) placed after transport controls with divider separation
- Buttons disabled when no undo/redo actions available, tooltips show action name (e.g., "Undo Rename Track")
- `LoopsRootView`: wired undo/redo state from `viewModel.undoManager` to ToolbarView parameters
- All parameters have defaults for backward compatibility — existing ToolbarView callers unaffected
- 10 new tests: ToolbarView accepts params, undo disabled initially, undo enabled after action, redo enabled after undo, redo disabled without redo, undo action name, redo action name, undo reverses action, redo reapplies action, state updates immediately
- All 831 tests pass

### Iteration 4 — #108 Undo history panel with toast notifications
- New `UndoHistoryEntry` model: `id: UUID`, `actionName: String`, `timestamp: Date`, `isCurrent: Bool`, computed `relativeTimeString` (just now / Ns ago / Nm ago / Nh ago)
- New `UndoToastMessage` model: `id: UUID`, `text: String` for auto-dismissing overlay
- `ProjectViewModel`: `undoHistory: [UndoHistoryEntry]` parallel array maintained alongside `registerUndo()` calls, `undoHistoryCursor: Int` tracks current position
- `ProjectViewModel`: `appendToUndoHistory(actionName:)` — trims future entries above cursor (invalidated by new action), appends new entry, updates cursor
- `ProjectViewModel`: `clearUndoHistory()` — called by `newProject()` and `open(from:)` to reset history on project load
- `ProjectViewModel`: `undoToastMessage: UndoToastMessage?` — set on undo/redo via `NSUndoManagerDidUndoChange` / `NSUndoManagerDidRedoChange` notification observers
- Notification observers use `queue: nil` + `MainActor.assumeIsolated` for synchronous firing on the main actor
- `handleUndoNotification()`: decrements cursor, sets toast "Undo: <action>"
- `handleRedoNotification()`: increments cursor, sets toast "Redo: <action>"
- New `UndoToastView`: auto-dismissing overlay with `.ultraThinMaterial` background, `RoundedRectangle` shape, shadow, slide+fade transition
- New `UndoHistoryView`: popover panel with scrollable list of history entries (reversed order, newest on top), accent highlight on current entry, relative timestamps, empty state text
- `ToolbarView`: new `undoHistory` and `undoHistoryCursor` parameters (with defaults), clock icon button (`.clock.arrow.circlepath`) next to undo/redo buttons, opens `UndoHistoryView` popover
- `LoopsRootView`: passes `viewModel.undoHistory` and `viewModel.undoHistoryCursor` to ToolbarView
- `LoopsRootView`: toast overlay mounted in ZStack at bottom center, `.onChange(of: undoToastMessage)` auto-dismisses after 2 seconds with animation
- 14 new tests: history tracks actions through undo/redo cycles, new action after undo trims future, history entries have action names, history entries have timestamps, newProject clears history, toast triggers on undo, toast triggers on redo, relativeTimeString (just now/minutes/hours), UndoHistoryEntry conformance, UndoToastMessage conformance, ToolbarView accepts history params, full undo cycle (3 actions undo all redo all)
- All 845 tests pass

### Iteration 5 — #109 Effect chain reordering UI
- `TrackInspectorView`: added `.onMove` modifier to effect list `ForEach` — wires to existing `onReorderEffects` callback
- `TrackInspectorView`: added drag handle icon (`line.3.horizontal`) to each effect row
- `ContainerInspector`: added `.onMove` modifier to effect list `ForEach` — wires to existing `onReorderEffects` callback
- `ContainerInspector`: added drag handle icon to each effect row
- `ContainerDetailEditor`: added `.onMove` modifier to effect list `ForEach` — wires to existing `onReorderEffects` callback
- `ContainerDetailEditor`: added drag handle icon to each effect row
- All three views use `Form > Section > ForEach` which supports native `.onMove` drag reordering on macOS
- Backend reorder methods (`reorderTrackEffects`, `reorderContainerEffects`) already existed with full undo/redo
- 3 new tests: track effect reorder undo+redo cycle, track effect reorder middle-to-end, container effect reorder undo+redo cycle
- All 848 tests pass

### Iteration 6 — #110 Extended MIDI mapping targets
- `MappableControl`: extended from 6 transport-only cases to 13 cases with associated values for mixer, navigation, and song targets
- New cases: `.trackVolume(trackIndex:)`, `.trackPan(trackIndex:)`, `.trackMute(trackIndex:)`, `.trackSolo(trackIndex:)`, `.trackSend(trackIndex:sendIndex:)`, `.trackSelect(trackIndex:)`, `.songSelect(songIndex:)`
- Custom Codable with backward-compatible decode: old plain-string format (`"playPause"`) and new keyed format (`{"type":"trackVolume","trackIndex":0}`) both supported
- `isContinuous` property: true for volume/pan/send (CC value scaling); `valueRange` returns (min, max) per control type
- `transportControls`, `mixerControls(trackCount:)`, `navigationControls(trackCount:songCount:)` static helpers for categorized enumeration
- `MIDIDispatcher`: added `onContinuousControlTriggered: ((MappableControl, Float) -> Void)?` callback — continuous controls (volume/pan/send) scale CC 0-127 to their value range and fire continuous callback; toggle controls (mute/solo/select) fire existing `onControlTriggered`
- `MIDIMappingView`: replaced single flat list with categorized sections (Transport, Mixer, Navigation, Foot Pedal Presets)
- Mixer section: per-track disclosure groups showing volume/pan/mute/solo controls with learn/clear buttons
- "Bank Assign..." menu: maps sequential CCs to sequential tracks for volume, pan, mute, or solo in a single action
- Navigation section: track select and song select entries per track/song
- `LoopsRootView.setupMIDIParameterDispatch()`: added control dispatcher alongside parameter dispatcher — handles all new control types:
  - Toggle controls: mute/solo toggle by track index, track select sets `selectedTrackID`, song select calls `selectSong(id:)`, next/previous song support (setlist perform mode or index-based)
  - Continuous controls: track volume (0-2), pan (-1 to +1), send level (0-1) applied via `ProjectViewModel` methods
- `ProjectViewModel`: added `onMIDIMappingsChanged` callback (fired on mapping changes from MIDIMappingView), `setTrackSendLevel(trackID:sendIndex:level:)` method with clamping and undo
- `MIDIMappingView`: fires `onMIDIMappingsChanged` on learn, clear, preset, and bank-assign operations for live dispatcher sync
- 30 new tests: MappableControl Codable round-trip (all 7 new cases + all transport cases), backward-compat legacy string decode (all 6 original cases), MIDIMapping with new controls round-trip, isContinuous/valueRange properties, displayName for all cases, transportControls/mixerControls/navigationControls helpers, MIDILearnController for trackVolume, MIDIDispatcher continuous routing (volume CC→2.0, pan CC→-1.0..+1.0), toggle routing (mute/songSelect via CC with value), bank-style mapping dispatch, ProjectViewModel mute/solo toggle, song select, volume/pan clamping, send level guard, onMIDIMappingsChanged callback
- All 878 tests pass

# ============================================================
# PRD #105: UX Polish, Keyboard Focus, Undo Workflow, MIDI Editing & Layout
# ============================================================

## Issue Dependency Graph
# #111 Virtual MIDI keyboard — no blockers
# #112 Resizable track row heights — no blockers
# #113 MIDI editor / Piano roll — no blockers
# #114 Copy containers and tracks between songs — no blockers
# #115 Resizable tracks panel (header width) — no blockers
# #116 Inline I/O controls on track headers — no blockers
# #117 Incremental audio engine graph updates — no blockers
# #118 Auto-open plugin window after adding effect — no blockers
# #119 Clean up automation lanes and MIDI mappings on effect/instrument removal — no blockers
# #120 Reset individual linked container field overrides to parent value — no blockers
# #121 Resolve linked container fields in inspector display — no blockers

## Completed
### Iteration 1 — #111 Virtual MIDI keyboard
- New `VirtualKeyboardView`: 2-octave piano layout (C3–B4 default) with white/black keys rendered via ZStack overlay
- Mouse/trackpad click sends note-on with velocity determined by vertical position on key (top=soft 1, bottom=loud 127)
- Release sends note-off, visual feedback (accent color highlight) on pressed keys
- Octave shift buttons (chevron left/right) change displayed range, clamped to octaves 0–8
- `PianoLayout` enum: `isBlackKey`, `whiteKeyIndex`, `blackKeyWhiteIndex`, `noteName`, `velocity` utility methods
- `PlaybackScheduler.sendMIDINoteToTrack`: routes MIDI messages to the first instrument AU unit found for the given track (via subgraph lookup)
- `TransportViewModel.sendVirtualNote`: public API forwarding to PlaybackScheduler
- `ToolbarView`: piano keyboard toggle button (pianokeys SF Symbol) with accent color when active
- `MainContentView`: virtual keyboard docked at bottom of center content (below timeline/mixer), conditionally shown via `isVirtualKeyboardVisible` binding
- `MainContentView`: Cmd+Shift+K keyboard shortcut to toggle virtual keyboard visibility
- `LoopsRootView`: `isVirtualKeyboardVisible` state wired to ToolbarView binding and MainContentView binding
- Notes route to the selected track's instrument via `projectViewModel.selectedTrackID`
- 19 new tests: PianoLayout (black/white key identification, velocity top/bottom/mid/clamp, note names, white key index, black key position), note ranges (C3-B4 default, octave shift up/down), MIDI message bytes (noteOn/noteOff/channel 1), key counts (14 white + 10 black per 2 octaves), PlaybackScheduler no-op without subgraphs, TransportViewModel no-op without scheduler
- All 897 tests pass

### Iteration 2 — #112 Resizable track row heights
- `TimelineViewModel`: `trackHeights: [ID<Track>: CGFloat]` dictionary for per-track custom row heights
- `TimelineViewModel`: `defaultTrackHeight = 80`, `minimumTrackHeight = 40` static constants
- `TimelineViewModel`: `baseTrackHeight(for:)` returns custom height or default, `setTrackHeight(_:for:)` with minimum clamping, `resetTrackHeight(for:)` removes custom height
- `TrackHeaderView`: added `onResizeTrack: ((CGFloat) -> Void)?` and `onResetTrackHeight: (() -> Void)?` callbacks
- New `TrackResizeHandle` view: 6pt invisible hit area at bottom edge of track header, `NSCursor.resizeUpDown` on hover, `DragGesture` tracks delta from start height, double-tap resets to default
- `MainContentView`: `trackHeaderWithActions` uses `baseTrackHeight(for:)` instead of hardcoded 80, wires resize/reset callbacks to `TimelineViewModel`
- `MainContentView`: master track and `regularTrackListContentHeight` also use per-track base heights
- `TimelineView`: `totalContentHeight` and `ForEach` track lanes use `baseTrackHeight(for:)` for per-track sizing
- 7 new tests: default height 80pt, set/get custom height, minimum height enforcement (40pt), reset to default, independent heights across tracks, automation uses custom base, TimelineView totalContentHeight with custom heights
- All 904 tests pass

### Iteration 3 — #113 MIDI editor / Piano roll
- `MIDISequence.swift`: new model file with `SnapResolution` enum (whole through 1/32), `MIDINoteEvent` struct (pitch, velocity, startBeat, duration, channel), `MIDISequence` struct with sorted/filtered queries
- `Container.swift`: added `midiSequence: MIDISequence?` field with backward-compatible decoding, `hasMIDI` computed property
- `ContainerField.swift`: added `.midiSequence` case for clone override tracking
- `PlaybackScheduler.swift`: MIDI containers now get instrument subgraphs in `prepare()`, MIDI note scheduling via 60Hz timer (note-on/off with `scheduleMIDIEventBlock`), `activeMIDINotes` tracking with note-off on stop
- `PianoRollView.swift`: full piano roll editor with Canvas grid, note rendering with velocity opacity, drag to move/resize, double-click to create, shift-click multi-select, snap-to-grid toolbar, `VelocityLaneView` for per-note velocity editing, `PianoRollLayout` coordinate mapping helpers
- `MIDIFileImporter.swift`: standard MIDI file parser (format 0/1, variable-length quantities, running status, tempo meta events)
- `MIDINoteMinimapView.swift`: compact Canvas preview of MIDI notes inside timeline container rectangles
- `ProjectViewModel.swift`: added `setContainerMIDISequence`, `addMIDINote`, `removeMIDINote`, `updateMIDINote` (all with undo/redo and clone override marking), `importMIDIFile` for .mid file import
- `MainContentView.swift`: `openContainerEditor()` routes MIDI containers to piano roll sheet, audio containers to detail editor
- `TrackLaneView.swift`: extended `.onDrop` handler to detect .mid/.midi files and call `onDropMIDIFile`
- `TimelineView.swift`: wired `onDropMIDIFile` callback to `ProjectViewModel.importMIDIFile`
- `ContainerView.swift`: added `MIDINoteMinimapView` overlay for containers with MIDI sequences
- 38 new tests across 3 suites: MIDISequence model/serialization/clone resolution (16), MIDI file parser (9), ProjectViewModel MIDI editing + PianoRollLayout mapping (13)
- All 943 tests pass

### Iteration 4 — #114 Copy containers and tracks between songs
- `ProjectViewModel`: `findMatchingTrack(in:name:kind:)` — finds matching track in target song by name first, then by kind; excludes master tracks
- `ProjectViewModel`: `copyContainerToSong(trackID:containerID:targetSongID:)` — copies a container to a different song, placing it in a matching track or creating a new track if none matches; preserves all container fields including MIDI sequences; supports undo
- `ProjectViewModel`: `copyTrackToSong(trackID:targetSongID:)` — copies entire track with all containers, effects, routing, automation, and expression pedal config to a different song; creates new track in target song; reindexes tracks; supports undo
- `ProjectViewModel`: `otherSongs` computed property — returns list of (id, name) tuples for all songs except the current one, used by context menus
- `ContainerView`: added `onCopyToSong` callback and `otherSongs` parameter; context menu shows "Copy to Song…" submenu with list of other songs when multiple songs exist
- `TrackLaneView`: added `onCopyContainerToSong` callback and `otherSongs` parameter, passes through to ContainerView
- `TimelineView`: wires `onCopyContainerToSong` to `projectViewModel.copyContainerToSong` and passes `projectViewModel.otherSongs`
- `MainContentView`: track header context menu adds "Copy Track to Song…" submenu (non-master tracks only) listing all other songs, wired to `projectViewModel.copyTrackToSong`
- Track matching: name match first (exact match), kind match fallback, create new track if no match found
- Cross-song copies are independent (new IDs, not linked clones); linked clone relationships preserved within copied tracks
- 10 new tests: copy container to song by name match, copy container creates new track when no match, copy track with all containers, track matching logic (name/kind/none), undo cross-song paste, copy track preserves effects, cannot copy to same song, cannot copy master track, otherSongs excludes current, copy preserves MIDI sequence
- All 953 tests pass

### Iteration 5 — #115 Resizable tracks panel (header width)
- `TimelineViewModel`: `trackHeaderWidth: CGFloat` (default 160) stored property for column width
- `TimelineViewModel`: `defaultHeaderWidth = 160`, `minHeaderWidth = 100`, `maxHeaderWidth = 400` static constants
- `TimelineViewModel`: `setTrackHeaderWidth(_:)` method with min/max clamping
- `TrackHeaderView`: added `headerWidth: CGFloat` parameter (default 160), replaced hard-coded `width: 160` in outer frame and automation sub-lane labels
- `MainContentView`: replaced all hard-coded `width: 160` for track headers (ruler spacer, sections label, track header column, master track header, both add-track buttons) with `timelineViewModel.trackHeaderWidth`
- `MainContentView`: new `headerColumnResizeHandle` computed property — 4pt vertical bar with `NSCursor.resizeLeftRight` on hover, `DragGesture` that calls `setTrackHeaderWidth` with drag delta, placed between header column and timeline in all four layout areas (ruler, sections, track area, master track)
- `MainContentView`: `headerDragStartWidth` `@State` tracks initial width at drag start for delta calculation
- All track headers resize together (column-level, not per-track)
- Width persists during the session via `TimelineViewModel` observable state
- 6 new tests: default 160pt, set stores value, clamps to min (100pt), clamps to max (400pt), exact boundaries, persists during session
- All 959 tests pass

### Iteration 6 — #117 Incremental audio engine graph updates
- Graph fingerprinting: `TrackGraphFingerprint`, `ContainerGraphFingerprint`, `EffectShapeFingerprint` structs capture the "shape" of the audio graph (effect components, container recordings, instruments) — preset data and mix params excluded since they don't require graph rebuild
- `PlaybackScheduler.prepare()` now stores graph fingerprints after building, enabling incremental comparison on subsequent calls
- `PlaybackScheduler.prepareIncremental()`: diffs new song against stored fingerprints, identifies changed/added/removed tracks, pre-loads AU units while engine runs (Phase 1), then briefly stops engine only for the synchronous attach/connect of changed tracks (Phase 2), unchanged tracks' player nodes resume automatically after engine restart
- `PlaybackScheduler.cleanupTrackSubgraph()`: tears down a single track's container subgraphs, effects, and mixer node without touching other tracks
- `PlaybackScheduler.cleanupMasterChain()`: tears down only the master mixer chain; reconnects unchanged track mixers to new master output
- `PlaybackScheduler.playChangedTracks()`: reschedules containers only on rebuilt tracks from the current bar position, restarts automation timer with updated song data
- `PlaybackScheduler.currentPlaybackBar()`: computes current position from wall-clock reference for mid-playback position capture
- `PlaybackScheduler.isActive`: public property for checking if playback is in progress
- `PlaybackScheduler.play()` now sets `playbackStartTime`/`playbackStartBar` immediately, ensuring position tracking works even without automation timer
- `PlaybackScheduler.restartAutomationTimer()`: preserves playback position continuity when restarting the timer after incremental updates
- `TransportViewModel.refreshPlaybackGraph()`: public API for mid-playback graph updates — calls `prepareIncremental()` + `playChangedTracks()` when playing, or invalidates cache for next play() when stopped
- Master track changes handled: if master effects change, master chain is rebuilt and all track mixers are reconnected to the new output target
- 8 new tests: prepareIncremental no changes (empty set), single track changed (only that track rebuilt), preserve unchanged track's player node (same instance), fallback to full prepare without prior fingerprints, currentPlaybackBar nil when stopped, currentPlaybackBar near fromBar after play, rapid incremental cycles (no crashes), playChangedTracks schedules only specified tracks
- All 967 tests pass

### Iteration 7 — #116 Inline I/O controls on track headers
- `TrackHeaderView`: added `availableInputPorts: [InputPort]`, `availableOutputPorts: [OutputPort]`, `availableMIDIDevices: [MIDIInputDevice]` parameters (all default `[]`)
- `TrackHeaderView`: added `onSetInputPort: ((String?) -> Void)?`, `onSetOutputPort: ((String?) -> Void)?`, `onSetMIDIInput: ((String?, UInt8?) -> Void)?` callbacks (all default nil)
- Audio tracks: replaced read-only input/output text labels with `Menu` pickers listing available ports + "Default" option
- MIDI tracks: replaced read-only device/channel text labels with `Menu` pickers listing available MIDI devices + "All Devices" option, and channels 1–16 + "Omni" option
- Master track: replaced read-only output text label with `Menu` picker listing available output ports + "Default" option
- All pickers use `.menuStyle(.borderlessButton)` and `.menuIndicator(.hidden)` for compact inline appearance matching existing header layout
- MIDI device picker preserves current channel when changing device; channel picker preserves current device when changing channel
- `MainContentView.trackHeaderWithActions()`: wired `availableInputPorts` (from `settingsViewModel?.inputPorts`), `availableOutputPorts` (from `settingsViewModel?.outputPorts`), `availableMIDIDevices` (from `engineManager?.midiManager.availableInputDevices()`), and all three selection callbacks to existing `ProjectViewModel` methods (`setTrackInputPort`, `setTrackOutputPort`/`setMasterOutputPort`, `setTrackMIDIInput`)
- All routing changes go through existing undo-enabled ProjectViewModel methods — no new undo code needed
- 10 new tests: inline input port selection, inline output port selection, inline MIDI device selection, inline MIDI channel selection, inline master output port selection, selecting Default clears port, inline routing change undo/redo, TrackHeaderView accepts ports and devices, MIDI device/channel change preserves other field
- All 976 tests pass

### Iteration 8 — #118 Auto-open plugin window after adding effect
- `MainContentView`: all three `onAddEffect` closures (containerDetailEditorSheet, containerInspectorContent, trackInspectorContent) now call `PluginWindowManager.shared.open()` immediately after `addContainerEffect` / `addTrackEffect`
- Container effect closures pass `onPresetChanged` callback wired to `projectViewModel.updateContainerEffectPreset` so preset saves work from the auto-opened window
- Track effect closure passes `onPresetChanged: nil` (matching existing inspector behavior)
- All auto-opened windows use `liveAudioUnit: nil` and `presetData: nil` since the effect was just created and isn't in the engine graph yet — standalone AU instantiation handles async loading
- Manually opening plugin windows from inspector effect rows still works unchanged
- 3 new tests: auto-open after add effect (window visible with nil preset), auto-open while another plugin window is open (both visible), auto-opened window receives preset callback on close
- All 979 tests pass

### Iteration 9 — #119 Clean up automation lanes and MIDI mappings on effect/instrument removal
- `ProjectViewModel.removeTrackEffect()`: after removing effect, removes all `trackAutomationLanes` and `midiParameterMappings` targeting the removed effect's `effectIndex`; decrements `effectIndex` in remaining lanes/mappings that referenced effects after the removed one
- `ProjectViewModel.removeContainerEffect()`: after removing effect, removes all container `automationLanes` and `midiParameterMappings` targeting the removed effect's `effectIndex`; decrements `effectIndex` in remaining lanes/mappings for higher-indexed effects; marks `.automation` field as overridden
- `ProjectViewModel.reorderTrackEffects()`: captures old→new index mapping from the move operation; updates `effectIndex` in all `trackAutomationLanes` and `midiParameterMappings` to match new ordering
- `ProjectViewModel.reorderContainerEffects()`: captures old→new index mapping; updates `effectIndex` in container `automationLanes` and `midiParameterMappings`; marks `.automation` field as overridden
- `ProjectViewModel.setContainerInstrumentOverride(nil)`: removes container `automationLanes` where `effectIndex == instrumentParameterEffectIndex` (-2); removes `midiParameterMappings` targeting the instrument; marks `.automation` field as overridden
- All cleanup operations happen within the same `registerUndo()` transaction as the effect/instrument removal, so undo restores everything atomically
- 8 new tests: track effect removal cleans up automation+MIDI, track effect removal decrements higher indices, track effect reorder updates indices, container effect removal cleans up automation+MIDI, container effect removal decrements higher indices, container effect reorder updates indices, instrument override removal cleans up automation+MIDI, undo track effect removal restores automation+MIDI
- All 987 tests pass

### Iteration 10 — #120 Reset individual linked container field overrides to parent value
- `Container`: new `copyField(from:field:)` mutating method — copies a single field's value from a source container, mapping each `ContainerField` case to its corresponding properties (e.g., `.effects` → `insertEffects` + `isEffectChainBypassed`, `.fades` → `enterFade` + `exitFade`)
- `ProjectViewModel`: new `resetContainerField(containerID:field:)` — validates clone has parent and field is overridden, copies parent's current value via `copyField(from:field:)`, removes field from `overriddenFields`, registers undo action ("Reset <fieldDisplayName>")
- `LinkedClipInspectorView`: added `onResetField: ((ContainerField) -> Void)?` callback parameter; overridden fields now show a reset button (arrow.uturn.backward.circle icon) next to the "Overridden" badge; non-overridden fields show no reset button
- `ContainerInspector`: added `onResetField` parameter, passes through to `LinkedClipInspectorView`
- `MainContentView`: wired `onResetField` callback to `projectViewModel.resetContainerField(containerID:field:)` for clone containers
- After reset, the field is removed from `overriddenFields` so future parent edits propagate via `resolved()`
- 7 new tests: reset removes field from overriddenFields, reset copies parent's current value, after reset clone inherits future parent edits via resolved(), undo restores override and original value, reset non-overridden field is no-op, reset effects field copies parent's effect chain, Container.copyField copies all field types correctly
- All 994 tests pass

### Iteration 11 — #121 Resolve linked container fields in inspector display
- `MainContentView.containerInspectorContent`: resolves linked clone containers via `container.resolved(parent:)` before passing to `ContainerInspector` — inspector now shows parent's current values for non-overridden fields
- `MainContentView.containerDetailEditorSheet`: same resolution applied to `ContainerDetailEditor` — detail editor also shows resolved values
- Resolution reuses existing `parentContainer` lookup (avoids duplicate `findContainer` call)
- `ContainerInspector`: new `isFieldInherited(_:)` helper — returns true when container is a clone and the field is not in `overriddenFields`
- `ContainerInspector`: new `inheritedBadge()` view — "Inherited" label with arrow.down.circle icon, secondary styling, rounded background
- Section headers for Effects, Enter Actions, Exit Actions, Enter Fade, Exit Fade, Automation, Loop Settings, and Boundary Mode now show "Inherited" badge when the corresponding field is inherited from parent
- Container name row shows inline "Inherited" badge next to the name TextField when `.name` field is inherited
- Edit callbacks still use the clone's container ID — editing an inherited field correctly creates an override on the clone (auto-override mechanism unchanged)
- What the inspector shows now matches what PlaybackScheduler produces (both use `resolved()`)
- 7 new tests: clone resolved shows parent's current effects, edit parent effects updates clone resolved, override shows clone's own values, resolved preserves clone ID for edits, editing inherited field creates override, resolved display matches playback, non-clone unchanged
- All 1001 tests pass

# ============================================================
# PRD #122: Performance — Reduce Unnecessary View Invalidation
# Issues: #123-#130 (8 vertical slices)
# ============================================================

## Issue Dependency Graph
# #123 Extract SelectionState from ProjectViewModel — no blockers
# #124 Extract ClipboardState from ProjectViewModel — no blockers
# #125 Extract UndoState from ProjectViewModel — no blockers
# #126 Extract ExportState and MIDILearnState from ProjectViewModel — no blockers
# #127 Isolate playhead rendering from timeline view tree — no blockers
# #128 Per-track meter isolation in MixerView — no blockers
# #129 Add Equatable memoization to ContainerView and TrackLaneView — blocked by #123
# #130 Lazy stacking for timeline tracks and mixer strips — no blockers

## Completed
### Iteration 12 — #123 Extract SelectionState from ProjectViewModel
- `SelectionState`: new `@Observable @MainActor` class with the four selection properties (`selectedTrackID`, `selectedContainerID`, `selectedContainerIDs`, `selectedSectionID`) and mutual exclusion logic
- `SelectionState.deselectAll()`: clears all four selection properties
- `ProjectViewModel`: new `selectionState` property (instance of `SelectionState`); four selection properties become delegating computed properties (`get`/`set` through `selectionState`)
- `ProjectViewModel.selectAllContainers()`, `deselectAll()`, `selectTrackByIndex(_:)`: delegate to `selectionState` internally
- `MainContentView`: new `selectionState: SelectionState` parameter; all selection reads/writes use `selectionState` directly instead of `projectViewModel`
- `TimelineView`: new `selectionState: SelectionState` parameter; container selection reads/writes use `selectionState` directly
- `LoopsAppEntry`: MIDI control dispatch reads/writes use `vm.selectionState.selectedTrackID`; extracted `mainContentView` computed property to reduce body type-checking complexity
- All existing call sites (methods on ProjectViewModel like `addContainer`, `removeContainer`, `cloneContainer` etc.) continue to work via the delegating computed properties
- 10 new tests: standalone properties default nil, track clears container+containerIDs, container clears track, deselectAll clears all, VM delegates containerID, VM delegates trackID, VM delegates sectionID, VM delegates containerIDs, nil track keeps container, nil container keeps track
- All 1011 tests pass

### Iteration 13 — #124 Extract ClipboardState from ProjectViewModel
- `ClipboardState`: new `@Observable @MainActor` class with three clipboard properties (`clipboard`, `clipboardBaseBar`, `clipboardSectionRegion`) and `hasContent` computed property
- `ClipboardContainerEntry` struct moved from ProjectViewModel.swift to ClipboardState.swift
- `ProjectViewModel`: new `clipboardState` property (instance of `ClipboardState`); three clipboard properties become delegating computed properties (`get`/`set` through `clipboardState`)
- All copy/paste methods (`copyContainer`, `copyContainersInRange`, `copySectionWithMetadata`, `pasteContainersToOriginalTracks`, `pasteContainers`) continue to work via delegating properties
- `MainContentView`: new `clipboardState: ClipboardState` parameter (defaults to `projectViewModel.clipboardState`); `handlePaste()` reads `clipboardState.hasContent` instead of `projectViewModel.clipboard`
- `TimelineView`: new `clipboardState: ClipboardState` parameter (defaults to `projectViewModel.clipboardState`); `hasClipboard` flag reads from `clipboardState.clipboard` instead of `projectViewModel.clipboard`
- All 1011 tests pass

### Iteration 14 — #125 Extract UndoState from ProjectViewModel
- `UndoState`: new `@Observable @MainActor` class with `undoHistory`, `undoHistoryCursor`, `undoToastMessage` properties
- `UndoState.appendToHistory(actionName:)`: adds entry, trims future entries above cursor, marks current
- `UndoState.handleUndo(redoActionName:)`: moves cursor back, sets toast message
- `UndoState.handleRedo(undoActionName:)`: moves cursor forward, sets toast message
- `UndoState.clear()`: resets history array and cursor
- `ProjectViewModel`: new `undoState` property (instance of `UndoState`); three undo display properties become delegating computed properties (`get`/`set` through `undoState`)
- `ProjectViewModel`: `handleUndoNotification()`, `handleRedoNotification()`, `appendToUndoHistory()`, `clearUndoHistory()` all delegate to `undoState`
- `ToolbarView`: replaced `undoHistory: [UndoHistoryEntry]` and `undoHistoryCursor: Int` parameters with single `undoState: UndoState` parameter; reads history/cursor from `undoState` directly
- `LoopsRootView`: passes `viewModel.undoState` to ToolbarView; toast overlay reads from `viewModel.undoState.undoToastMessage` instead of `viewModel.undoToastMessage`
- 8 new tests: standalone defaults empty, appendToHistory adds entries, handleUndo cursor/toast, handleRedo cursor/toast, clear resets, appendTrimsFuture, VM delegates undoHistory, VM delegates undoToast
- All 1019 tests pass

### Iteration 15 — #126 Extract ExportState and MIDILearnState from ProjectViewModel
- `ExportState`: new `@Observable @MainActor` class with `isExportSheetPresented: Bool` property
- `MIDILearnState`: new `@Observable @MainActor` class with `isMIDIParameterLearning: Bool`, `midiLearnTargetPath: EffectPath?` properties
- `MIDILearnState`: `startLearn(targetPath:)`, `cancelLearn()`, `clearLearn()` methods for state transitions
- `ProjectViewModel`: new `exportState` property (instance of `ExportState`); `isExportSheetPresented` becomes delegating computed property through `exportState`
- `ProjectViewModel`: new `midiLearnState` property (instance of `MIDILearnState`); `isMIDIParameterLearning` and `midiLearnTargetPath` become delegating computed properties through `midiLearnState`
- `ProjectViewModel`: `startMIDIParameterLearn`, `cancelMIDIParameterLearn`, `completeMIDIParameterLearn` delegate to `midiLearnState` for state management
- `LoopsAppEntry`: MIDI event handler reads `midiLearnState.isMIDIParameterLearning` directly for observation isolation
- `MainContentView`: passes `midiLearnState.isMIDIParameterLearning` to TrackInspectorView for observation isolation
- All existing tests pass unchanged — proxy properties maintain backward compatibility
- All 1019 tests pass

### Iteration 16 — #127 Isolate playhead rendering from timeline view tree
- `PlayheadOverlayView`: new child view in PlayheadView.swift that wraps `PlayheadView` and isolates `playheadBar` observation from `TimelineView.body`
- With `@Observable`, only `PlayheadOverlayView.body` reads `viewModel.playheadX` (which accesses `playheadBar`), so 60fps playhead ticks no longer trigger re-evaluation of the entire `TimelineView` body
- `TimelineView`: replaced direct `PlayheadView(xPosition: viewModel.playheadX, ...)` with `PlayheadOverlayView(viewModel:height:)` — TrackLaneView and ContainerView bodies are no longer re-evaluated on playhead tick
- Playhead position, zoom, and scroll behavior unchanged
- All 1019 tests pass

### Iteration 17 — #128 Per-track meter isolation in MixerView
- `MixerStripState`: new `@Observable @MainActor` class holding a single track's `level: Float` with ~30fps throttling via `CFAbsoluteTime` timestamp comparison (`throttleInterval = 1.0/30.0`)
- `MixerStripState.updateLevel(_:)`: only accepts a new level if ≥33ms has elapsed since the last update
- `MixerViewModel`: replaced `trackLevels: [ID<Track>: Float]` dictionary with `stripStates: [ID<Track>: MixerStripState]` — each track gets its own observable, isolating observation
- `MixerViewModel`: replaced `masterLevel: Float` with `masterStripState: MixerStripState` for consistent master meter isolation
- `MixerViewModel.stripState(for:)`: returns or creates the per-track `MixerStripState` on demand
- `MixerViewModel.updateLevel(trackID:peak:)` and `updateMasterLevel(_:)`: delegate to the per-track/master `MixerStripState.updateLevel()`, inheriting throttling
- `MixerViewModel.removeStripState(for:)`: removes per-track state when tracks are deleted
- `MixerStripView`: replaced `level: Float` parameter with `stripState: MixerStripState` — each strip observes only its own state object, so level changes on track 1 don't re-evaluate track 2's strip
- `MixerView.stripView(for:)`: passes `mixerViewModel.masterStripState` for master, `mixerViewModel.stripState(for:)` for regular tracks
- `PlaybackScheduler`: added `onTrackLevelUpdate: ((ID<Track>, Float) -> Void)?` callback and `trackLevelTapIDs` set for tracking installed taps
- `PlaybackScheduler.installTrackLevelTaps()`: installs `AVAudioNode` taps on each track mixer node, fires `onTrackLevelUpdate` with peak level via `AudioEngineManager.peakLevel(from:)`
- `PlaybackScheduler.removeTrackLevelTaps()`: removes all per-track taps, called in `cleanup()` and `cleanupTrackSubgraph()`
- `TransportViewModel`: added `onTrackLevelUpdate` callback, wires to scheduler on creation, installs taps after `prepare()` and `prepareIncremental()`
- `LoopsAppEntry`: wires `transportViewModel.onTrackLevelUpdate` to `mixerViewModel.updateLevel(trackID:peak:)` via `@MainActor` dispatch
- 9 new tests: MixerStripState defaults zero, updateLevel sets level, throttles rapid updates, stripState same instance, different instances per track, updateLevel isolation, removeStripState, master independent from tracks, scheduler callback wiring
- All 1028 tests pass

### Iteration 18 — #129 Add Equatable memoization to ContainerView and TrackLaneView
- `ContainerView`: added `Equatable` extension comparing only data inputs (container, pixelsPerBar, height, isSelected, trackColor, waveformPeaks, isClone, overriddenFields, otherSongs) — closures are excluded from comparison
- `TrackLaneView`: added `Equatable` extension comparing only data inputs (track, pixelsPerBar, totalBars, height, selectedContainerID, hasClipboard, isAutomationExpanded, automationSubLanePaths, selectedBreakpointID, otherSongs) — closures are excluded
- `TrackLaneView`: wrapped `ContainerView` with `.equatable()` modifier so SwiftUI skips body re-evaluation when container data hasn't changed (adjacent container changes no longer trigger re-render)
- `TimelineView`: wrapped `TrackLaneView` with `.equatable()` modifier so SwiftUI skips body re-evaluation when track data hasn't changed (different track changes no longer trigger re-render)
- `otherSongs` tuple arrays compared element-wise (id + name) since tuples are not automatically Equatable
- 14 new tests: ContainerView equal with same data/different closures, unequal on container/isSelected/waveformPeaks/pixelsPerBar/otherSongs/overriddenFields changes, nil vs non-nil peaks; TrackLaneView equal with same data/different closures, unequal on track/selectedContainerID/automationSubLanePaths/hasClipboard/container-count changes
- All 1042 tests pass

### Iteration 19 — #130 Lazy stacking for timeline tracks and mixer strips
- `TimelineView`: replaced eager `VStack(spacing: 0)` with `LazyVStack(spacing: 0, pinnedViews: [])` for track lanes — off-screen tracks are no longer rendered
- `MainContentView`: replaced eager `VStack(spacing: 0)` with `LazyVStack(spacing: 0, pinnedViews: [])` for track headers — stays in sync with lazy timeline tracks
- `MixerView`: replaced eager `HStack(spacing: 4)` with `LazyHStack(spacing: 4)` for mixer strips — off-screen strips are no longer rendered
- Master track remains pinned outside the lazy stacks (rendered separately at bottom)
- Playhead overlay, grid overlay, and range selection overlay use pre-computed `displayHeight` — unaffected by lazy rendering
- Drag-to-reorder (`onDrag`/`onDrop` on individual track headers) works unchanged with lazy stacking
- Automation sub-lane expand/collapse unaffected — per-track height is computed independently via `viewModel.trackHeight(for:baseHeight:)`
- `.equatable()` memoization on `TrackLaneView` (from #129) still applies within the lazy stack
- All 1042 tests pass
